<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Anneaux !</title>
    <link rel="stylesheet" href="styles.css">
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
</head>
<body>
<div id="app">
    <div v-if="!isWorkoutStarted && !isEditing">
        <h2>Choisissez votre séance</h2>
        <select v-model="selectedWorkoutPlan">
            <option :value="null" disabled>-- Sélectionnez un programme --</option>
            <option v-for="(workout, key) in predefinedWorkouts" :key="key" :value="workout.plan">{{ workout.name }}</option>
        </select>
        <br>
        <div class="main-buttons">
            <button @click="editWorkout" :disabled="!selectedWorkoutPlan" class="btn-edit">Éditer la séance</button>
            <button @click="startWorkout" :disabled="!selectedWorkoutPlan" class="btn-start">Commencer directement</button>
        </div>
    </div>

    <div v-if="isEditing" class="editor-view">
        <div class="editor-header">
            <h2>Éditer la séance</h2>
            <div class="editor-actions">
                <button @click="cancelEdit" class="btn-secondary">Annuler</button>
                <button @click="saveAndStart" class="btn-primary">Sauver et Commencer</button>
            </div>
        </div>

        <button @click="addNewExercise" class="btn-add" style="width: 100%; margin-bottom: 15px; padding: 10px;">+ Ajouter un exercice</button>

        <div v-for="(exercise, index) in editingPlan" :key="index" class="exercise-editor">
            <div class="exercise-header">
                <div class="exercise-title">{{ exercise.nom }}</div>
                <div class="exercise-controls">
                    <button @click="moveExerciseUp(index)" :disabled="index === 0" class="btn-secondary">↑</button>
                    <button @click="moveExerciseDown(index)" :disabled="index === editingPlan.length - 1" class="btn-secondary">↓</button>
                    <button @click="removeExercise(index)" class="btn-remove">Supprimer</button>
                </div>
            </div>
            
            <div class="exercise-details">
                <!-- Paramètres de base -->
                <div class="exercise-param">
                    <label>Nom:</label>
                    <input v-model="exercise.nom" type="text" placeholder="Nom de l'exercice">
                </div>
                
                <div class="exercise-param">
                    <label>Type:</label>
                    <select v-model="exercise.type" @change="onTypeChange(index)">
                        <option value="serie">Série</option>
                        <option value="EMOM">EMOM</option>
                    </select>
                </div>

                <!-- Paramètres spécifiques au type série -->
                <div v-if="exercise.type === 'serie' && exercise.number !== undefined" class="param-section">
                    <h4>Paramètres Série</h4>
                    <div class="exercise-param">
                        <label>Nombre de séries:</label>
                        <input v-model.number="exercise.number" type="number" min="1" max="20">
                    </div>
                    <div class="exercise-param">
                        <label>Repos entre séries:</label>
                        <input v-model.number="exercise.rest" type="number" min="0" max="600">
                        <span>secondes</span>
                    </div>
                </div>

                <!-- Paramètres spécifiques au type EMOM -->
                <div v-if="exercise.type === 'EMOM' && exercise.temps" class="param-section">
                    <h4>Paramètres EMOM</h4>
                    <div class="exercise-param">
                        <label>Intervalle:</label>
                        <input v-model.number="exercise.temps.every" type="number" min="10" max="300">
                        <span>secondes</span>
                    </div>
                    <div class="exercise-param">
                        <label>Durée totale:</label>
                        <input v-model.number="exercise.temps.during" type="number" min="30" max="1800">
                        <span>secondes</span>
                    </div>
                    
                    <div class="exercise-param">
                        <label>Répéter le bloc:</label>
                        <input v-model="exercise.hasRepeat" type="checkbox" @change="onEmomRepeatChange(index)">
                        <span>Oui</span>
                    </div>
                    
                    <div v-if="exercise.hasRepeat && exercise.repeat" class="exercise-param">
                        <label>Nombre de répétitions:</label>
                        <input v-model.number="exercise.repeat.number" type="number" min="1" max="10">
                        <span>fois</span>
                    </div>
                    <div v-if="exercise.hasRepeat && exercise.repeat" class="exercise-param">
                        <label>Pause entre blocs:</label>
                        <input v-model.number="exercise.repeat.pause_between" type="number" min="0" max="300">
                        <span>secondes</span>
                    </div>
                </div>

                <!-- Paramètres de timing -->
                <div class="param-section">
                    <h4>Timing</h4>
                    <div class="exercise-param">
                        <label>Pause après exercice:</label>
                        <input v-model.number="exercise.pause_after" type="number" min="0" max="600">
                        <span>secondes</span>
                    </div>
                    <div class="exercise-param">
                        <label>Préparation avant:</label>
                        <input v-model.number="exercise.countdown_before" type="number" min="0" max="60">
                        <span>secondes</span>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div v-if="isWorkoutStarted" class="workout-view">
        <button @click="togglePause" class="pause-btn">{{ isPaused ? '▶️' : '⏸️' }}</button>
        <button @click="toggleFullscreen" class="fullscreen-btn">⛶</button>
        <button @click="skipToNextExercise" class="skip-btn" v-if="currentExerciseIndex < workoutPlan.length">>></button>
        <div class="total-time-display">{{ formattedTotalTime }}</div>
        
        <div class="main-display">
            <div class="circle-timer">
                <svg viewBox="0 0 100 100">
                    <circle class="timer-track" cx="50" cy="50" r="45"></circle>
                    <circle class="timer-progress" cx="50" cy="50" r="45" :style="progressStyle"></circle>
                </svg>
                <div class="timer-text-container">
                    <div class="timer-text" :style="{ color: phaseColor }">{{ timerDisplay }}</div>
                    <div class="timer-subtext" :style="{ color: phaseColor }">{{ timerSubtext }}</div>
                    <div v-if="isBreakTime" class="timer-pause-text">en pause</div>
                </div>
            </div>
            <h1 :style="{ color: phaseColor }">{{ exerciseName }}</h1>
            <button v-if="isSerieMode && !isPaused" @click="finishSerieSet" class="ok-btn">OK</button>
        </div>

        <div id="plan-container">
            <template v-for="(exercise, index) in workoutPlan" :key="index">
                <li v-if="index >= currentExerciseIndex" :class="{ current: index === currentExerciseIndex }">
                    <div class="exercise-main plan-list">
                        <span>{{ formatExerciseTitle(exercise) }}</span>
                    </div>
                </li>
            </template>
        </div>
    </div>
</div>
<script>
    const { createApp } = Vue;
    createApp({
        data() {
            return {
                predefinedWorkouts: {},
                selectedWorkoutPlan: null,
                workoutPlan: [],
                currentExerciseIndex: -1, currentRepetition: 0, currentEmomRound: 0, isPaused: false, isSerieMode: false, isBreakTime: false,
                totalWorkoutTime: 0, totalTimeInterval: null,
                exerciseName: '', timerDisplay: '', timerSubtext: '',
                countdownInterval: null, isWorkoutStarted: false, wakeLock: null, audioContext: null,
                progressStyle: {}, circleCircumference: 0, phaseColor: 'var(--action-color)',
                // Variables pour l'éditeur
                isEditing: false,
                editingPlan: [],
                originalPlan: null
            };
        },
        async created() {
            const manifestResponse = await fetch('workouts/manifest.json');
            const manifest = await manifestResponse.json();
            const workouts = {};
            for (const fileName of manifest) {
                const workoutName = fileName.replace('.json', '');
                const workoutResponse = await fetch(`workouts/${fileName}`);
                const workoutData = await workoutResponse.json();
                workouts[workoutName] = workoutData;
            }
            this.predefinedWorkouts = workouts;
            this.circleCircumference = 2 * Math.PI * 45; // 45 is the radius 'r' of the circle in SVG
            this.setCircleProgress(0, 'action');

            document.addEventListener('visibilitychange', () => {
                if (document.visibilityState === 'visible' && this.isWorkoutStarted && !this.isPaused) {
                    this.requestWakeLock();
                }
            });
        },
        computed: {
            formattedTotalTime() { if (this.totalWorkoutTime <= 0) return '00:00'; const m = Math.floor(this.totalWorkoutTime / 60); const s = this.totalWorkoutTime % 60; return `${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`; },
        },
        methods: {
            toggleFullscreen() {
                const isInFullScreen = document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement || document.msFullscreenElement;

                if (!isInFullScreen) {
                    const el = document.documentElement;
                    if (el.requestFullscreen) {
                        el.requestFullscreen();
                    } else if (el.mozRequestFullScreen) { /* Firefox */
                        el.mozRequestFullScreen();
                    } else if (el.webkitRequestFullscreen) { /* Chrome, Safari & Opera */
                        el.webkitRequestFullscreen();
                    } else if (el.msRequestFullscreen) { /* IE/Edge */
                        el.msRequestFullscreen();
                    }
                } else {
                    if (document.exitFullscreen) {
                        document.exitFullscreen();
                    } else if (document.mozCancelFullScreen) { /* Firefox */
                        document.mozCancelFullScreen();
                    } else if (document.webkitExitFullscreen) { /* Chrome, Safari & Opera */
                        document.webkitExitFullscreen();
                    } else if (document.msExitFullscreen) { /* IE/Edge */
                        document.msExitFullscreen();
                    }
                }
            },
            // Méthodes pour l'éditeur de séance
            editWorkout() {
                if (!this.selectedWorkoutPlan) return;
                this.originalPlan = JSON.parse(JSON.stringify(this.selectedWorkoutPlan));
                this.editingPlan = JSON.parse(JSON.stringify(this.selectedWorkoutPlan));
                
                // S'assurer que tous les exercices ont les bonnes propriétés
                this.editingPlan = this.editingPlan.map(exercise => {
                    const newExercise = { ...exercise };
                    
                    // Propriétés communes
                    if (newExercise.pause_after === undefined) newExercise.pause_after = 30;
                    if (newExercise.countdown_before === undefined) newExercise.countdown_before = 5;
                    
                    // Propriétés spécifiques par type
                    if (newExercise.type === 'serie') {
                        if (!newExercise.number) newExercise.number = 3;
                        if (newExercise.rest === undefined) newExercise.rest = 60;
                    } else if (newExercise.type === 'EMOM') {
                        if (!newExercise.temps) {
                            newExercise.temps = { every: 60, during: 300 };
                        } else {
                            // S'assurer que temps a toutes les propriétés nécessaires
                            if (!newExercise.temps.every) newExercise.temps.every = 60;
                            if (!newExercise.temps.during) newExercise.temps.during = 300;
                        }
                        // Initialiser hasRepeat basé sur l'existence de repeat
                        newExercise.hasRepeat = !!newExercise.repeat;
                        if (newExercise.hasRepeat && !newExercise.repeat) {
                            newExercise.repeat = { number: 1, pause_between: 30 };
                        }
                    }
                    
                    return newExercise;
                });
                
                this.isEditing = true;
                document.body.classList.add('editing');
                document.body.classList.remove('workout');
            },
            cancelEdit() {
                this.isEditing = false;
                this.editingPlan = [];
                this.originalPlan = null;
                document.body.classList.remove('editing');
                document.getElementById('app').classList.remove('workout-mode');
            },
            saveAndStart() {
                // Nettoyer les propriétés helper avant de sauvegarder
                const cleanedPlan = JSON.parse(JSON.stringify(this.editingPlan));
                cleanedPlan.forEach((exercise, index) => {
                    // Supprimer la propriété helper hasRepeat
                    const originalExercise = this.editingPlan[index];
                    delete exercise.hasRepeat;
                    // Si EMOM sans répétition, s'assurer que repeat n'existe pas
                    if (exercise.type === 'EMOM' && !originalExercise.hasRepeat) {
                        delete exercise.repeat;
                    }
                });
                
                this.selectedWorkoutPlan = cleanedPlan;
                this.isEditing = false;
                document.body.classList.remove('editing');
                this.startWorkout();
            },
            removeExercise(index) {
                if (this.editingPlan.length > 1) {
                    this.editingPlan.splice(index, 1);
                }
            },
            moveExerciseUp(index) {
                if (index > 0) {
                    const exercise = this.editingPlan.splice(index, 1)[0];
                    this.editingPlan.splice(index - 1, 0, exercise);
                }
            },
            moveExerciseDown(index) {
                if (index < this.editingPlan.length - 1) {
                    const exercise = this.editingPlan.splice(index, 1)[0];
                    this.editingPlan.splice(index + 1, 0, exercise);
                }
            },
            increaseReps(index) {
                if (this.editingPlan[index].type === 'serie') {
                    this.editingPlan[index].number++;
                }
            },
            decreaseReps(index) {
                if (this.editingPlan[index].type === 'serie' && this.editingPlan[index].number > 1) {
                    this.editingPlan[index].number--;
                }
            },
            increaseEmomReps(index) {
                if (this.editingPlan[index].type === 'EMOM' && this.editingPlan[index].repeat) {
                    this.editingPlan[index].repeat.number++;
                }
            },
            decreaseEmomReps(index) {
                if (this.editingPlan[index].type === 'EMOM' && this.editingPlan[index].repeat && this.editingPlan[index].repeat.number > 1) {
                    this.editingPlan[index].repeat.number--;
                }
            },
            onTypeChange(index) {
                const exercise = this.editingPlan[index];
                
                // Créer un nouvel objet exercice avec les bonnes propriétés
                const newExercise = {
                    nom: exercise.nom,
                    type: exercise.type,
                    pause_after: exercise.pause_after !== undefined ? exercise.pause_after : 30,
                    countdown_before: exercise.countdown_before !== undefined ? exercise.countdown_before : 5
                };
                
                if (exercise.type === 'serie') {
                    // Propriétés spécifiques aux séries
                    newExercise.number = exercise.number || 3;
                    newExercise.rest = exercise.rest !== undefined ? exercise.rest : 60;
                } else if (exercise.type === 'EMOM') {
                    // Propriétés spécifiques aux EMOM
                    newExercise.temps = {
                        every: (exercise.temps && exercise.temps.every) || 60,
                        during: (exercise.temps && exercise.temps.during) || 300
                    };
                    newExercise.hasRepeat = false;
                    // Ne pas ajouter repeat par défaut
                }
                
                // Remplacer l'exercice entier pour assurer la réactivité
                this.editingPlan.splice(index, 1, newExercise);
            },
            onEmomRepeatChange(index) {
                const exercise = this.editingPlan[index];
                if (exercise.hasRepeat) {
                    // Activer les répétitions
                    if (!exercise.repeat) {
                        exercise.repeat = { number: 1, pause_between: 30 };
                    }
                } else {
                    // Désactiver les répétitions
                    delete exercise.repeat;
                }
                // Déclencher une mise à jour réactive
                this.editingPlan[index] = { ...exercise };
            },
            addNewExercise() {
                const newExercise = {
                    nom: "Nouvel exercice",
                    type: "serie",
                    number: 3,
                    rest: 60,
                    pause_after: 30,
                    countdown_before: 5
                };
                this.editingPlan.push(newExercise);
            },
            setCircleProgress(percent, phase) {
                const offset = this.circleCircumference - (percent / 100) * this.circleCircumference;
                let color = 'var(--action-color)';
                if (phase === 'prep') color = 'var(--prep-color)';
                else if (phase === 'pause') color = 'var(--pause-color)';
                else if (phase === 'done') color = 'var(--done-color)';
                this.progressStyle = {
                    strokeDasharray: `${this.circleCircumference}`,
                    strokeDashoffset: offset,
                    stroke: color
                };
                this.phaseColor = color;
            },
            formatExerciseTitle(exercise) {
                let parts = [exercise.nom.split(' ').map(word => word.toUpperCase()).join(' ')];
                if (exercise.type) { parts.push(exercise.type.toUpperCase()); }
                let repCount = 0;
                if (exercise.type === 'serie' && exercise.number) { repCount = exercise.number; }
                else if (exercise.type === 'EMOM') {
                    if (exercise.repeat && exercise.repeat.number) { repCount = exercise.repeat.number; }
                    else if (exercise.temps && exercise.temps.during && exercise.temps.every) { repCount = Math.floor(exercise.temps.during / exercise.temps.every); }
                }
                if (repCount > 1) { parts.push(repCount); }
                return parts.join(' - ');
            },
            skipToNextExercise() { if (this.countdownInterval) { clearInterval(this.countdownInterval); } this.startNextExercise(); },
            speak(text, lang = 'en-US') { if ('speechSynthesis' in window) { window.speechSynthesis.cancel(); const u = new SpeechSynthesisUtterance(text); u.lang = lang; u.rate = 0.9; window.speechSynthesis.speak(u); } },
            beep(freq = 880, duration = 100) { if (!this.audioContext) return; const o = this.audioContext.createOscillator(); const g = this.audioContext.createGain(); o.connect(g); o.frequency.value = freq; o.type = 'sine'; g.connect(this.audioContext.destination); g.gain.setValueAtTime(1, this.audioContext.currentTime); g.gain.exponentialRampToValueAtTime(0.00001, this.audioContext.currentTime + duration / 1000); o.start(); o.stop(this.audioContext.currentTime + duration / 1000); },
            async requestWakeLock() { if ('wakeLock' in navigator && !this.isPaused) try { this.wakeLock = await navigator.wakeLock.request('screen'); } catch (e) { console.error(e); } },
            async releaseWakeLock() { if (this.wakeLock) { await this.wakeLock.release(); this.wakeLock = null; } },
            togglePause() { this.isPaused = !this.isPaused; if (this.isPaused) { if ('speechSynthesis' in window) window.speechSynthesis.pause(); this.releaseWakeLock(); } else { if ('speechSynthesis' in window) window.speechSynthesis.resume(); this.requestWakeLock(); } },
            startWorkout() {
                if (!this.selectedWorkoutPlan) return;
                if (!this.audioContext) this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                if (this.countdownInterval) clearInterval(this.countdownInterval);
                if (this.totalTimeInterval) clearInterval(this.totalTimeInterval);
                const plan = this.selectedWorkoutPlan;
                this.workoutPlan = plan; this.currentExerciseIndex = -1; this.isWorkoutStarted = true; this.isPaused = false; this.isSerieMode = false;
                this.totalWorkoutTime = 0;
                this.totalTimeInterval = setInterval(() => { if (!this.isPaused) this.totalWorkoutTime++; }, 1000);
                document.body.classList.add('workout');
                document.body.classList.remove('editing');
                document.getElementById('app').classList.add('workout-mode');
                this.requestWakeLock();
                this.startNextExercise();
            },
            decideNextStep() {
                const exercise = this.workoutPlan[this.currentExerciseIndex];
                if (exercise.type === 'serie' && this.currentRepetition < exercise.number) {
                    this.currentRepetition++;
                    this.runPause(exercise.rest || 0, () => this.startSerieMode(exercise), 'pause', `${this.currentRepetition}/${exercise.number}`);
                } else if (exercise.repeat && this.currentRepetition < exercise.repeat.number) {
                    let subtext = null;
                    if (exercise.type === 'EMOM' && exercise.repeat) {
                        subtext = `${this.currentRepetition}/${exercise.repeat.number}`;
                    }
                    this.runPause(exercise.repeat.pause_between || 0, () => {
                        this.currentRepetition++;
                        this.startMainTimer(exercise);
                    }, 'pause', subtext);
                } else {
                    if (exercise.repeat || exercise.type === 'serie') { this.currentRepetition++; }
                    const nextIndex = this.currentExerciseIndex + 1;
                    if (nextIndex < this.workoutPlan.length) {
                        this.exerciseName = this.workoutPlan[nextIndex].nom.toUpperCase();
                    }
                    const pauseDuration = (nextIndex < this.workoutPlan.length) ? (exercise.pause_after || 0) : 0;
                    this.runPause(pauseDuration, () => this.startNextExercise());
                }
            },
            startNextExercise() {
                this.isSerieMode = false;
                this.currentExerciseIndex++;
                if (this.currentExerciseIndex >= this.workoutPlan.length) { this.finishWorkout(); return; }
                this.currentRepetition = 1;
                this.currentEmomRound = 0;
                const exercise = this.workoutPlan[this.currentExerciseIndex];
                this.exerciseName = exercise.nom.toUpperCase();
                this.startPreparation(exercise);
            },
            startPreparation(data) {
                let subtext = null;
                if (data.type === 'EMOM' && data.repeat) {
                    subtext = `${this.currentRepetition}/${data.repeat.number}`;
                }
                this.runPause(data.countdown_before || 0, () => this.startMainTimer(data), 'prep', subtext);
            },
            startMainTimer(data) { this.beep(1200, 150); if (data.type === 'serie') this.startSerieMode(data); else if (data.type === 'EMOM') this.startEmomTimer(data); },
            startEmomTimer(data) {
                this.isBreakTime = false;
                this.currentEmomRound = 1;
                let totalDuration = data.temps.during || 0; const roundDuration = data.temps.every || 60; let currentRoundTime = roundDuration;
                let halfTimeAnnouncedInRound = false;
                const update = () => {
                    this.timerDisplay = `${String(Math.floor(currentRoundTime/60)).padStart(2,'0')}:${String(currentRoundTime%60).padStart(2,'0')}`;
                    const percent = roundDuration > 0 ? ((roundDuration - currentRoundTime) / roundDuration) * 100 : 0;
                    this.setCircleProgress(percent, 'action');
                    if (data.repeat) { this.timerSubtext = `${this.currentRepetition}/${data.repeat.number}`; }
                    else { this.timerSubtext = `${this.currentEmomRound}/${Math.floor(data.temps.during / data.temps.every)}`; }
                };
                update();
                this.countdownInterval = setInterval(() => {
                    if (this.isPaused) return;
                    totalDuration--; currentRoundTime--;
                    if (currentRoundTime === 10 && roundDuration >= 30) this.speak('Ten seconds left', 'en-US');
                    if (currentRoundTime > 0 && currentRoundTime <= 4) this.beep(880, 100);
                    if (!halfTimeAnnouncedInRound && currentRoundTime > 0 && currentRoundTime <= roundDuration / 2) {
                        this.speak('Half time!', 'en-US');
                        halfTimeAnnouncedInRound = true;
                    }
                    if (currentRoundTime <= 0) { 
                        this.beep(1200, 150); currentRoundTime = roundDuration; 
                        halfTimeAnnouncedInRound = false;
                        if(totalDuration >= 0) this.currentEmomRound++;
                    }
                    update();
                    if (totalDuration < 0) { 
                        clearInterval(this.countdownInterval); 
                        if (data.temps.during) this.currentEmomRound = (data.temps.during / data.temps.every) + 1;
                        this.decideNextStep(); 
                    }
                }, 1000);
            },
            startSerieMode(data) { this.isBreakTime = false; this.timerSubtext = `${this.currentRepetition}/${data.number}`; this.timerDisplay = 'GO!'; this.isSerieMode = true; this.setCircleProgress(100, 'action'); },
            finishSerieSet() { this.isSerieMode = false; this.decideNextStep(); },
            runPause(duration, onComplete, phase = 'pause', subtext = null) {
                this.isBreakTime = true;
                this.beep(1400, 200);
                if (duration > 0) {
                    this.timerSubtext = subtext !== null ? subtext : (phase === 'prep') ? 'Préparation' : 'Pause';
                    let remaining = duration;
                    let halfTimeAnnounced = false;
                    const update = () => {
                        this.timerDisplay = remaining;
                        const percent = duration > 0 ? ((duration - remaining) / duration) * 100 : 0;
                        this.setCircleProgress(percent, phase);
                    };
                    const onPauseComplete = () => {
                        this.isBreakTime = false;
                        onComplete();
                    };
                    update();
                    this.countdownInterval = setInterval(() => {
                        if (this.isPaused) return;
                        remaining--;
                        if (remaining === 10 && duration >= 30) this.speak('Ten seconds left', 'en-US');
                        if (!halfTimeAnnounced && remaining > 0 && remaining <= duration / 2) {
                            this.speak('Half time!', 'en-US');
                            halfTimeAnnounced = true;
                        }
                        if (remaining > 0 && remaining <= 3) this.beep(880, 100);
                        update();
                        if (remaining < 0) { clearInterval(this.countdownInterval); onPauseComplete(); }
                    }, 1000);
                } else { this.isBreakTime = false; onComplete(); }
            },
            finishWorkout() { 
                if (this.totalTimeInterval) clearInterval(this.totalTimeInterval); 
                this.currentExerciseIndex = this.workoutPlan.length;
                this.exerciseName = 'SÉANCE TERMINÉE'; 
                this.timerDisplay = '💪';
                this.timerSubtext = 'Bravo !';
                this.setCircleProgress(100, 'done');
                this.speak('Workout complete! Well done', 'en-US');
                this.isPaused = false; 
                this.isSerieMode = false; 
                this.releaseWakeLock();
                // Ajouter possibilité de retour après 5 secondes
                setTimeout(() => {
                    this.isWorkoutStarted = false;
                    document.body.classList.remove('workout');
                    document.getElementById('app').classList.remove('workout-mode');
                }, 5000);
            }
        },
        unmounted() { this.releaseWakeLock(); if (this.totalTimeInterval) clearInterval(this.totalTimeInterval); }
    }).mount('#app');
</script>
</body>
</html>