<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Anneaux !</title>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <style>
        :root {
            --prep-color: #ff9800;
            --action-color: #a855f7; /* Purple from screenshot */
            --pause-color: #17a2b8;
            --done-color: #28a745;
            --track-color: #373737;
            --bg-color: #000;
            --text-color: #fff;
            --text-secondary-color: #aaa;
        }
        html, body { height: 100%; width: 100%; overflow: hidden; }
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; display: flex; align-items: center; justify-content: center; margin: 0; background-color: var(--bg-color); color: var(--text-color); }
        #app { text-align: center; background: var(--bg-color); padding: 1rem; width: 100%; height: 100%; display: flex; flex-direction: column; justify-content: center; position: relative; }
        select { width: 95%; padding: 0.8rem; margin-bottom: 1.5rem; border-radius: 4px; border: 1px solid #ccc; font-size: 1.2rem; background-color: #333; color: white; -webkit-appearance: none; -moz-appearance: none; appearance: none; background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23fff%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E'); background-repeat: no-repeat; background-position: right .7em top 50%; background-size: .65em auto; }
        button { padding: 1rem 2rem; font-size: 1.2rem; cursor: pointer; border: none; background-color: var(--action-color); color: white; border-radius: 8px; width: 90%; }
        button:disabled { background-color: #a0a0a0; cursor: not-allowed; }
        
        .workout-view { display: flex; flex-direction: column; height: 100%; }
        .main-display { flex-grow: 1; display: flex; flex-direction: column; justify-content: center; align-items: center; }
        #plan-container { flex-shrink: 0; padding: 10px; border-top: 1px solid var(--track-color); max-height: 40%; overflow-y: auto; background-color: #111; }
        .plan-list { list-style: none; padding: 0; margin: 0; text-align: left; font-size: 1.6em}
        .plan-list li { display: flex; flex-direction: column; padding: 8px 5px; border-bottom: 1px solid var(--track-color); font-size: 1rem; }
        .plan-list li .exercise-main { display: flex; align-items: center; }
        .plan-list li.current { color: gray; }

        .sub-tasks { padding-left: 25px; margin-top: 5px; display: flex; align-items: center; flex-wrap: wrap; }
        .sub-tasks label { font-size: 0.8rem; margin-right: 5px; font-style: italic; }

        h1 {
            margin-top: 1rem;
            margin-bottom: 1rem;
            font-size: 1.8rem;
            font-weight: bold;
            color: var(--text-color);
            white-space: normal;
            overflow-wrap: break-word;
            padding: 0 1rem;
        }
        
        .circle-timer { width: 80vw; max-width: 400px; position: relative; aspect-ratio: 1 / 1; }
        .circle-timer svg { transform: rotate(-90deg); width: 100%; height: 100%; }
        .timer-track, .timer-progress { fill: none; stroke-width: 10; }
        .timer-track { stroke: var(--track-color); stroke-dasharray: 5 5; }
        .timer-progress { stroke: var(--action-color); stroke-linecap: round; transition: stroke-dashoffset 0.3s linear, stroke 0.3s ease; }

        .timer-text-container { position: absolute; top: 0; left: 0; right: 0; bottom: 0; display: flex; flex-direction: column; align-items: center; justify-content: center; }
        .timer-text { font-size: clamp(3.5rem, 18vw, 5.5rem); font-weight: bold; font-family: "Courier New", Courier, monospace; color: var(--action-color); }
        .timer-subtext { font-size: 2.2rem; color: var(--text-secondary-color); margin-top: 10px; }

        .pause-btn { position: absolute; top: 15px; left: 15px; width: 45px; height: 45px; padding: 0; font-size: 1.3rem; border-radius: 50%; z-index: 10; background-color: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); color: #fff; }
        .total-time-display { position: absolute; top: 20px; right: 20px; font-size: 1.3rem; color: var(--text-secondary-color); }
        
        .next-btn, .ok-btn {
            width: auto; padding: 10px 20px; font-size: 1rem; margin-top: 0px; color: white; border: none; border-radius: 8px; cursor: pointer; margin-bottom: 10px;
        }
        .next-btn { background-color: #6c757d; }
        .ok-btn { background-color: var(--done-color); }
    </style>
</head>
<body>
<div id="app">
    <div v-if="!isWorkoutStarted">
        <h2>Choisissez votre séance</h2>
        <select v-model="selectedWorkoutPlan">
            <option :value="null" disabled>-- Sélectionnez un programme --</option>
            <option v-for="(workout, key) in predefinedWorkouts" :key="key" :value="workout.plan">{{ workout.name }}</option>
        </select>
        <br>
        <button @click="startWorkout" :disabled="!selectedWorkoutPlan">Commencer la séance</button>
    </div>
    <div v-if="isWorkoutStarted" class="workout-view">
        <button @click="togglePause" class="pause-btn">{{ isPaused ? '▶️' : '⏸️' }}</button>
        <div class="total-time-display">{{ formattedTotalTime }}</div>
        
        <div class="main-display">
            <div class="circle-timer">
                <svg viewBox="0 0 100 100">
                    <circle class="timer-track" cx="50" cy="50" r="45"></circle>
                    <circle class="timer-progress" cx="50" cy="50" r="45" :style="progressStyle"></circle>
                </svg>
                <div class="timer-text-container">
                    <div class="timer-text">{{ timerDisplay }}</div>
                    <div class="timer-subtext">{{ timerSubtext }}</div>
                </div>
            </div>
            <h1>{{ exerciseName }}</h1>
            <button @click="skipToNextExercise" class="next-btn" v-if="!isSerieMode && currentExerciseIndex < workoutPlan.length">Suivant</button>
            <button v-if="isSerieMode && !isPaused" @click="finishSerieSet" class="ok-btn">OK</button>
        </div>

        <div id="plan-container">
            <template v-for="(exercise, index) in workoutPlan" :key="index">
                <li v-if="index >= currentExerciseIndex" :class="{ current: index === currentExerciseIndex }">
                    <div class="exercise-main plan-list">
                        <span>{{ formatExerciseTitle(exercise) }}</span>
                    </div>
                </li>
            </template>
        </div>
    </div>
</div>
<script>
    const { createApp } = Vue;
    createApp({
        data() {
            return {
                predefinedWorkouts: {},
                selectedWorkoutPlan: null,
                workoutPlan: [],
                currentExerciseIndex: -1, currentRepetition: 0, currentEmomRound: 0, isPaused: false, isSerieMode: false,
                totalWorkoutTime: 0, totalTimeInterval: null,
                exerciseName: '', timerDisplay: '', timerSubtext: '',
                countdownInterval: null, isWorkoutStarted: false, wakeLock: null, audioContext: null,
                progressStyle: {}, circleCircumference: 0
            };
        },
        async created() {
            const manifestResponse = await fetch('workouts/manifest.json');
            const manifest = await manifestResponse.json();
            const workouts = {};
            for (const fileName of manifest) {
                const workoutName = fileName.replace('.json', '');
                const workoutResponse = await fetch(`workouts/${fileName}`);
                const workoutData = await workoutResponse.json();
                workouts[workoutName] = workoutData;
            }
            this.predefinedWorkouts = workouts;
            this.circleCircumference = 2 * Math.PI * 45; // 45 is the radius 'r' of the circle in SVG
            this.setCircleProgress(0, 'action');

            document.addEventListener('visibilitychange', () => {
                if (document.visibilityState === 'visible' && this.isWorkoutStarted && !this.isPaused) {
                    this.requestWakeLock();
                }
            });
        },
        computed: {
            formattedTotalTime() { if (this.totalWorkoutTime <= 0) return '00:00'; const m = Math.floor(this.totalWorkoutTime / 60); const s = this.totalWorkoutTime % 60; return `${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`; },
        },
        methods: {
            setCircleProgress(percent, phase) {
                const offset = this.circleCircumference - (percent / 100) * this.circleCircumference;
                let color = 'var(--action-color)';
                if (phase === 'prep') color = 'var(--prep-color)';
                else if (phase === 'pause') color = 'var(--pause-color)';
                this.progressStyle = {
                    strokeDasharray: `${this.circleCircumference}`,
                    strokeDashoffset: offset,
                    stroke: color
                };
            },
            formatExerciseTitle(exercise) {
                let parts = [exercise.nom.split(' ').map(word => word.toUpperCase()).join(' ')];
                if (exercise.type) { parts.push(exercise.type.toUpperCase()); }
                let repCount = 0;
                if (exercise.type === 'serie' && exercise.number) { repCount = exercise.number; }
                else if (exercise.type === 'EMOM') {
                    if (exercise.repeat && exercise.repeat.number) { repCount = exercise.repeat.number; }
                    else if (exercise.temps && exercise.temps.during && exercise.temps.every) { repCount = Math.floor(exercise.temps.during / exercise.temps.every); }
                }
                if (repCount > 1) { parts.push(repCount); }
                return parts.join(' - ');
            },
            skipToNextExercise() { if (this.countdownInterval) { clearInterval(this.countdownInterval); } this.startNextExercise(); },
            speak(text, lang = 'en-US') { if ('speechSynthesis' in window) { window.speechSynthesis.cancel(); const u = new SpeechSynthesisUtterance(text); u.lang = lang; u.rate = 0.9; window.speechSynthesis.speak(u); } },
            beep(freq = 880, duration = 100) { if (!this.audioContext) return; const o = this.audioContext.createOscillator(); const g = this.audioContext.createGain(); o.connect(g); o.frequency.value = freq; o.type = 'sine'; g.connect(this.audioContext.destination); g.gain.setValueAtTime(1, this.audioContext.currentTime); g.gain.exponentialRampToValueAtTime(0.00001, this.audioContext.currentTime + duration / 1000); o.start(); o.stop(this.audioContext.currentTime + duration / 1000); },
            async requestWakeLock() { if ('wakeLock' in navigator && !this.isPaused) try { this.wakeLock = await navigator.wakeLock.request('screen'); } catch (e) { console.error(e); } },
            async releaseWakeLock() { if (this.wakeLock) { await this.wakeLock.release(); this.wakeLock = null; } },
            togglePause() { this.isPaused = !this.isPaused; if (this.isPaused) { if ('speechSynthesis' in window) window.speechSynthesis.pause(); this.releaseWakeLock(); } else { if ('speechSynthesis' in window) window.speechSynthesis.resume(); this.requestWakeLock(); } },
            startWorkout() {
                if (!this.selectedWorkoutPlan) return;
                if (!this.audioContext) this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                if (this.countdownInterval) clearInterval(this.countdownInterval);
                if (this.totalTimeInterval) clearInterval(this.totalTimeInterval);
                const plan = this.selectedWorkoutPlan;
                this.workoutPlan = plan; this.currentExerciseIndex = -1; this.isWorkoutStarted = true; this.isPaused = false; this.isSerieMode = false;
                this.totalWorkoutTime = 0;
                this.totalTimeInterval = setInterval(() => { if (!this.isPaused) this.totalWorkoutTime++; }, 1000);
                this.requestWakeLock();
                this.startNextExercise();
            },
            decideNextStep() {
                const exercise = this.workoutPlan[this.currentExerciseIndex];
                if (exercise.type === 'serie' && this.currentRepetition < exercise.number) {
                    this.currentRepetition++;
                    this.runPause(exercise.rest || 0, () => this.startSerieMode(exercise), 'pause', `${this.currentRepetition}/${exercise.number}`);
                } else if (exercise.repeat && this.currentRepetition < exercise.repeat.number) {
                    let subtext = null;
                    if (exercise.type === 'EMOM' && exercise.repeat) {
                        subtext = `${this.currentRepetition}/${exercise.repeat.number}`;
                    }
                    this.runPause(exercise.repeat.pause_between || 0, () => {
                        this.currentRepetition++;
                        this.startMainTimer(exercise);
                    }, 'pause', subtext);
                } else {
                    if (exercise.repeat || exercise.type === 'serie') { this.currentRepetition++; }
                    const nextIndex = this.currentExerciseIndex + 1;
                    if (nextIndex < this.workoutPlan.length) {
                        this.exerciseName = this.workoutPlan[nextIndex].nom.toUpperCase();
                    }
                    const pauseDuration = (nextIndex < this.workoutPlan.length) ? (exercise.pause_after || 0) : 0;
                    this.runPause(pauseDuration, () => this.startNextExercise());
                }
            },
            startNextExercise() {
                this.isSerieMode = false;
                this.currentExerciseIndex++;
                if (this.currentExerciseIndex >= this.workoutPlan.length) { this.finishWorkout(); return; }
                this.currentRepetition = 1;
                this.currentEmomRound = 0;
                const exercise = this.workoutPlan[this.currentExerciseIndex];
                this.exerciseName = exercise.nom.toUpperCase();
                this.startPreparation(exercise);
            },
            startPreparation(data) {
                let subtext = null;
                if (data.type === 'EMOM' && data.repeat) {
                    subtext = `${this.currentRepetition}/${data.repeat.number}`;
                }
                this.runPause(data.countdown_before || 0, () => this.startMainTimer(data), 'prep', subtext);
            },
            startMainTimer(data) { this.beep(1200, 150); if (data.type === 'serie') this.startSerieMode(data); else if (data.type === 'EMOM') this.startEmomTimer(data); else this.startFullTimeTimer(data); },
            startFullTimeTimer(data) {
                this.timerSubtext = 'Action !';
                const duration = data.temps.secondes || 0; let remaining = duration;
                let halfTimeAnnounced = false;
                const update = () => {
                    if (remaining < 0) return;
                    this.timerDisplay = `${String(Math.floor(remaining / 60)).padStart(2, '0')}:${String(remaining % 60).padStart(2, '0')}`;
                    const percent = duration > 0 ? ((duration - remaining) / duration) * 100 : 0;
                    this.setCircleProgress(percent, 'action');
                };
                update();
                this.countdownInterval = setInterval(() => {
                    if (this.isPaused) return;
                    remaining--;
                    if (remaining === 10 && duration >= 30) this.speak('Ten seconds left', 'en-US');
                    if (remaining > 0 && remaining <= 4) this.beep(880, 100);
                    if (!halfTimeAnnounced && remaining > 0 && remaining <= duration / 2) {
                        this.speak('Half time!', 'en-US');
                        halfTimeAnnounced = true;
                    }
                    update();
                    if (remaining < 0) { clearInterval(this.countdownInterval); this.decideNextStep(); }
                }, 1000);
            },
            startEmomTimer(data) {
                this.currentEmomRound = 1;
                let totalDuration = data.temps.during || 0; const roundDuration = data.temps.every || 60; let currentRoundTime = roundDuration;
                let halfTimeAnnouncedInRound = false;
                const update = () => {
                    this.timerDisplay = `${String(Math.floor(currentRoundTime/60)).padStart(2,'0')}:${String(currentRoundTime%60).padStart(2,'0')}`;
                    const percent = roundDuration > 0 ? ((roundDuration - currentRoundTime) / roundDuration) * 100 : 0;
                    this.setCircleProgress(percent, 'action');
                    if (data.repeat) { this.timerSubtext = `${this.currentRepetition}/${data.repeat.number}`; }
                    else { this.timerSubtext = `${this.currentEmomRound}/${Math.floor(data.temps.during / data.temps.every)}`; }
                };
                update();
                this.countdownInterval = setInterval(() => {
                    if (this.isPaused) return;
                    totalDuration--; currentRoundTime--;
                    if (currentRoundTime === 10 && roundDuration >= 30) this.speak('Ten seconds left', 'en-US');
                    if (currentRoundTime > 0 && currentRoundTime <= 4) this.beep(880, 100);
                    if (!halfTimeAnnouncedInRound && currentRoundTime > 0 && currentRoundTime <= roundDuration / 2) {
                        this.speak('Half time!', 'en-US');
                        halfTimeAnnouncedInRound = true;
                    }
                    if (currentRoundTime <= 0) { 
                        this.beep(1200, 150); currentRoundTime = roundDuration; 
                        halfTimeAnnouncedInRound = false;
                        if(totalDuration >= 0) this.currentEmomRound++;
                    }
                    update();
                    if (totalDuration < 0) { 
                        clearInterval(this.countdownInterval); 
                        if (data.temps.during) this.currentEmomRound = (data.temps.during / data.temps.every) + 1;
                        this.decideNextStep(); 
                    }
                }, 1000);
            },
            startSerieMode(data) { this.timerSubtext = `${this.currentRepetition}/${data.number}`; this.timerDisplay = 'GO!'; this.isSerieMode = true; this.setCircleProgress(100, 'action'); },
            finishSerieSet() { this.isSerieMode = false; this.decideNextStep(); },
            runPause(duration, onComplete, phase = 'pause', subtext = null) {
                this.beep(1400, 200);
                if (duration > 0) {
                    this.timerSubtext = subtext !== null ? subtext : (phase === 'prep') ? 'Préparation' : 'Pause';
                    let remaining = duration;
                    let halfTimeAnnounced = false;
                    const update = () => {
                        this.timerDisplay = remaining;
                        const percent = duration > 0 ? ((duration - remaining) / duration) * 100 : 0;
                        this.setCircleProgress(percent, phase);
                    };
                    update();
                    this.countdownInterval = setInterval(() => {
                        if (this.isPaused) return;
                        remaining--;
                        if (remaining === 10 && duration >= 30) this.speak('Ten seconds left', 'en-US');
                        if (!halfTimeAnnounced && remaining > 0 && remaining <= duration / 2) {
                            this.speak('Half time!', 'en-US');
                            halfTimeAnnounced = true;
                        }
                        if (remaining > 0 && remaining <= 3) this.beep(880, 100);
                        update();
                        if (remaining < 0) { clearInterval(this.countdownInterval); onComplete(); }
                    }, 1000);
                } else { onComplete(); }
            },
            finishWorkout() { 
                if (this.totalTimeInterval) clearInterval(this.totalTimeInterval); 
                this.currentExerciseIndex = this.workoutPlan.length;
                this.exerciseName = 'SÉANCE TERMINÉE'; 
                this.timerDisplay = '💪';
                this.timerSubtext = 'Bravo !';
                this.setCircleProgress(100, 'done');
                this.speak('Workout complete! Well done', 'en-US');
                this.isPaused = false; 
                this.isSerieMode = false; 
                this.releaseWakeLock(); 
            }
        },
        unmounted() { this.releaseWakeLock(); if (this.totalTimeInterval) clearInterval(this.totalTimeInterval); }
    }).mount('#app');
</script>
</body>
</html>