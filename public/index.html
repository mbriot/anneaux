<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Anneaux !</title>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <style>
        :root { --prep-color: #ff9800; --action-color: #007bff; --pause-color: #17a2b8; --done-color: #28a745; }
        html, body { height: 100%; width: 100%; overflow: hidden; }
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; display: flex; align-items: center; justify-content: center; margin: 0; background-color: #f0f2f5; }
        #app { text-align: center; background: white; padding: 1rem; border-radius: 8px; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1); width: 100%; height: 100%; display: flex; flex-direction: column; justify-content: center; position: relative; }
        select { width: 95%; padding: 0.8rem; margin-bottom: 1.5rem; border-radius: 4px; border: 1px solid #ccc; font-size: 1.2rem; background-color: white; -webkit-appearance: none; -moz-appearance: none; appearance: none; background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23007CB2%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E'); background-repeat: no-repeat; background-position: right .7em top 50%; background-size: .65em auto; }
        button { padding: 1rem 2rem; font-size: 1.2rem; cursor: pointer; border: none; background-color: var(--action-color); color: white; border-radius: 8px; width: 90%; }
        button:disabled { background-color: #a0a0a0; cursor: not-allowed; }
        
        .workout-view { display: flex; flex-direction: column; height: 100%; }
        .main-display { flex-grow: 1; display: flex; flex-direction: column; justify-content: center; }
        #plan-container { flex-shrink: 0; padding: 10px; border-top: 1px solid #eee; max-height: 50%; overflow-y: auto; }
        .plan-list { list-style: none; padding: 0; margin: 0; text-align: left; }
        .plan-list li { display: flex; flex-direction: column; padding: 8px 5px; border-bottom: 1px solid #f0f0f0; font-size: 1rem; }
        .plan-list li .exercise-main { display: flex; align-items: center; }
        .plan-list li.completed { color: #999; }
        .plan-list li.completed .exercise-main { text-decoration: line-through; }
        .plan-list li input[type=checkbox] { margin-right: 10px; }
        .sub-tasks { padding-left: 25px; margin-top: 5px; display: flex; align-items: center; flex-wrap: wrap; }
        .sub-tasks label { font-size: 0.8rem; margin-right: 5px; font-style: italic; }
        .sub-tasks input[type=checkbox] { width: 12px; height: 12px; }

        h1 { margin-top: 0; margin-bottom: 0.5rem; font-size: 2rem; font-weight: bold; color: #333; white-space: normal; overflow-wrap: break-word; }
        #timerDisplay { font-size: clamp(3rem, 16vw, 5rem); font-weight: bold; font-family: "Courier New", Courier, monospace; transition: color 0.5s; white-space: nowrap; }
        .pause-btn { position: absolute; top: 15px; left: 15px; width: 45px; height: 45px; padding: 0; font-size: 1.3rem; border-radius: 50%; z-index: 10; background-color: rgba(0,0,0,0.1); border: 1px solid rgba(0,0,0,0.2); color: #333; }
        .total-time-display { position: absolute; top: 15px; right: 15px; font-size: 1.3rem; color: #6c757d; background: #f0f2f5; padding: 5px 10px; border-radius: 8px; }
        
        .next-btn, .ok-btn {
            width: auto;
            padding: 10px 20px;
            font-size: 1rem;
            margin-top: 1rem;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
        }
        .next-btn { background-color: #6c757d; }
        .ok-btn { background-color: var(--done-color); }

        .timer-prep { color: var(--prep-color); }
        .timer-action { color: var(--action-color); }
        .timer-pause { color: var(--pause-color); }
        .timer-done { color: var(--done-color); }
    </style>
</head>
<body>
<div id="app">
    <div v-if="!isWorkoutStarted">
        <h2>Choisissez votre séance</h2>
        <select v-model="selectedWorkoutPlan">
            <option :value="null" disabled>-- Sélectionnez un programme --</option>
            <option v-for="(workout, index) in predefinedWorkouts" :key="index" :value="workout.plan">
                {{ workout.name }}
            </option>
        </select>
        <br>
        <button @click="startWorkout" :disabled="!selectedWorkoutPlan">Commencer la séance</button>
    </div>
    <div v-if="isWorkoutStarted" class="workout-view">
        <button @click="togglePause" class="pause-btn">{{ isPaused ? '▶️' : '⏸️' }}</button>
        <div class="total-time-display">{{ formattedTotalTime }}</div>
        
        <div class="main-display">
            <h1>{{ exerciseName }}</h1>
            <div id="timerDisplay" :class="timerClass">{{ timerDisplay }}</div>
            <button @click="skipToNextExercise" class="next-btn" v-if="!isSerieMode && currentExerciseIndex < workoutPlan.length">Suivant</button>
            <button v-if="isSerieMode && !isPaused" @click="finishSerieSet" class="ok-btn">OK</button>
        </div>

        <div id="plan-container">
            <template v-for="(exercise, index) in workoutPlan" :key="index">
                <li v-if="index >= currentExerciseIndex - 1" :class="{ completed: index < currentExerciseIndex }">
                    <div class="exercise-main plan-list">
                        <input type="checkbox" :checked="index < currentExerciseIndex" disabled>
                        <span>{{ formatExerciseTitle(exercise) }}</span>
                    </div>
                    <div class="sub-tasks" v-if="exercise.type === 'serie' && exercise.number > 1">
                        <input type="checkbox" v-for="n in exercise.number" :key="'s'+n" :checked="index < currentExerciseIndex || (index === currentExerciseIndex && n < currentRepetition)" disabled>
                    </div>
                    <div class="sub-tasks" v-if="exercise.type === 'EMOM' && exercise.temps && exercise.temps.during >= exercise.temps.every">
                        <label>Tours:</label>
                        <input type="checkbox" v-for="n in Math.floor(exercise.temps.during / exercise.temps.every)" :key="'e'+n" :checked="index < currentExerciseIndex || (index === currentExerciseIndex && n < currentEmomRound)" disabled>
                    </div>
                    <div class="sub-tasks" v-if="exercise.repeat && exercise.repeat.number > 1">
                        <label>Reps:</label>
                        <input type="checkbox" v-for="n in exercise.repeat.number" :key="'er'+n" :checked="index < currentExerciseIndex || (index === currentExerciseIndex && n < currentRepetition)" disabled>
                    </div>
                </li>
            </template>
        </div>
    </div>
</div>
<script>
    const { createApp } = Vue;
    createApp({
        data() {
            return {
                predefinedWorkouts: {},
                selectedWorkoutPlan: null,
                workoutPlan: [],
                currentExerciseIndex: -1, currentRepetition: 0, currentEmomRound: 0, isPaused: false, isSerieMode: false,
                totalWorkoutTime: 0, totalTimeInterval: null,
                exerciseName: '', timerDisplay: '', timerClass: '',
                countdownInterval: null, isWorkoutStarted: false, wakeLock: null, audioContext: null
            };
        },
        async created() {
            const manifestResponse = await fetch('workouts/manifest.json');
            const manifest = await manifestResponse.json();

            const workouts = {};
            for (const fileName of manifest) {
                const workoutName = fileName.replace('.json', '');
                const workoutResponse = await fetch(`workouts/${fileName}`);
                const workoutData = await workoutResponse.json();
                workouts[workoutName] = workoutData;
            }
            this.predefinedWorkouts = workouts;
        },
        computed: {
            formattedTotalTime() { if (this.totalWorkoutTime <= 0) return '00:00'; const m = Math.floor(this.totalWorkoutTime / 60); const s = this.totalWorkoutTime % 60; return `${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`; },
        },
        methods: {
            formatExerciseTitle(exercise) {
                let parts = [exercise.nom];
                if (exercise.type) {
                    parts.push(exercise.type.toUpperCase());
                }

                let repCount = 0;
                if (exercise.type === 'serie' && exercise.number) {
                    repCount = exercise.number;
                } else if (exercise.type === 'EMOM') {
                    if (exercise.repeat && exercise.repeat.number) {
                        repCount = exercise.repeat.number;
                    } else if (exercise.temps && exercise.temps.during && exercise.temps.every) {
                        repCount = Math.floor(exercise.temps.during / exercise.temps.every);
                    }
                }

                if (repCount > 1) {
                    parts.push(repCount);
                }

                return parts.join(' - ');
            },
            skipToNextExercise() { if (this.countdownInterval) { clearInterval(this.countdownInterval); } this.startNextExercise(); },
            speak(text, lang = 'en-US') { if ('speechSynthesis' in window) { window.speechSynthesis.cancel(); const u = new SpeechSynthesisUtterance(text); u.lang = lang; u.rate = 0.9; window.speechSynthesis.speak(u); } },
            beep(freq = 880, duration = 100) { if (!this.audioContext) return; const o = this.audioContext.createOscillator(); const g = this.audioContext.createGain(); o.connect(g); o.frequency.value = freq; o.type = 'sine'; g.connect(this.audioContext.destination); g.gain.setValueAtTime(1, this.audioContext.currentTime); g.gain.exponentialRampToValueAtTime(0.00001, this.audioContext.currentTime + duration / 1000); o.start(); o.stop(this.audioContext.currentTime + duration / 1000); },
            async requestWakeLock() { if ('wakeLock' in navigator && !this.isPaused) try { this.wakeLock = await navigator.wakeLock.request('screen'); } catch (e) { console.error(e); } },
            async releaseWakeLock() { if (this.wakeLock) { await this.wakeLock.release(); this.wakeLock = null; } },
            togglePause() { this.isPaused = !this.isPaused; if (this.isPaused) { if ('speechSynthesis' in window) window.speechSynthesis.pause(); this.releaseWakeLock(); } else { if ('speechSynthesis' in window) window.speechSynthesis.resume(); this.requestWakeLock(); } },
            startWorkout() {
                if (!this.selectedWorkoutPlan) return;
                if (!this.audioContext) this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                if (this.countdownInterval) clearInterval(this.countdownInterval);
                if (this.totalTimeInterval) clearInterval(this.totalTimeInterval);
                
                const plan = this.selectedWorkoutPlan;
                this.workoutPlan = plan; this.currentExerciseIndex = -1; this.isWorkoutStarted = true; this.isPaused = false; this.isSerieMode = false;
                
                this.totalWorkoutTime = 0;
                this.totalTimeInterval = setInterval(() => { if (!this.isPaused) this.totalWorkoutTime++; }, 1000);
                this.requestWakeLock();
                this.startNextExercise();
            },
            decideNextStep() {
                const exercise = this.workoutPlan[this.currentExerciseIndex];
                // Is it a serie with more sets?
                if (exercise.type === 'serie' && this.currentRepetition < exercise.number) {
                    this.currentRepetition++;
                    this.runPause(exercise.rest || 0, () => this.startSerieMode(exercise));
                }
                // Is it a repeating block with more reps?
                else if (exercise.repeat && this.currentRepetition < exercise.repeat.number) {
                    this.currentRepetition++;
                    this.runPause(exercise.repeat.pause_between || 0, () => this.startMainTimer(exercise));
                }
                // Otherwise, the exercise is completely finished. Run the final pause.
                else {
                    // If the exercise that just finished was a repeating type,
                    // increment the repetition counter one last time to mark the final sub-task as complete on the UI.
                    if (exercise.repeat || exercise.type === 'serie') {
                        this.currentRepetition++;
                    }

                    const nextIndex = this.currentExerciseIndex + 1;
                    if (nextIndex < this.workoutPlan.length) {
                        this.exerciseName = this.workoutPlan[nextIndex].nom.toUpperCase();
                    }
                    this.runPause(exercise.pause_after || 0, () => this.startNextExercise());
                }
            },
            startNextExercise() {
                this.isSerieMode = false;
                this.currentExerciseIndex++;
                if (this.currentExerciseIndex >= this.workoutPlan.length) { this.finishWorkout(); return; }
                this.currentRepetition = 1;
                this.currentEmomRound = 0;
                const exercise = this.workoutPlan[this.currentExerciseIndex];
                this.exerciseName = exercise.nom.toUpperCase();
                this.startPreparation(exercise);
            },
            startPreparation(data) { this.runPause(data.countdown_before || 0, () => this.startMainTimer(data)); },
            startMainTimer(data) { this.beep(1200, 150); if (data.type === 'serie') this.startSerieMode(data); else if (data.type === 'EMOM') this.startEmomTimer(data); else this.startFullTimeTimer(data); },
            startFullTimeTimer(data) {
                this.timerClass = 'timer-action';
                const initialTotalSeconds = data.temps.secondes || 0; let totalSeconds = initialTotalSeconds; let halfTimeAnnounced = false;
                const updateDisplay = () => { if (totalSeconds < 0) return; this.timerDisplay = `${String(Math.floor(totalSeconds / 60)).padStart(2, '0')}:${String(totalSeconds % 60).padStart(2, '0')}`; };
                updateDisplay();
                this.countdownInterval = setInterval(() => {
                    if (this.isPaused) return;
                    totalSeconds--;
                    if (totalSeconds === 10) this.speak('Ten seconds left', 'en-US');
                    if (totalSeconds > 0 && totalSeconds <= 4) this.beep(880, 100);
                    if (!halfTimeAnnounced && totalSeconds > 0 && totalSeconds <= initialTotalSeconds / 2) { this.speak('Half time!', 'en-US'); halfTimeAnnounced = true; }
                    updateDisplay();
                    if (totalSeconds < 0) { clearInterval(this.countdownInterval); this.decideNextStep(); }
                }, 1000);
            },
            startEmomTimer(data) {
                this.timerClass = 'timer-action';
                this.currentEmomRound = 1;
                let totalDuration = data.temps.during || 0; const roundDuration = data.temps.every || 60; let currentRoundTime = roundDuration; let halfTimeAnnouncedInRound = false;
                const updateEmomDisplay = () => {
                    this.timerDisplay = `${String(Math.floor(currentRoundTime/60)).padStart(2,'0')}:${String(currentRoundTime%60).padStart(2,'0')}`;
                };
                updateEmomDisplay();
                this.countdownInterval = setInterval(() => {
                    if (this.isPaused) return;
                    totalDuration--; currentRoundTime--;
                    if (currentRoundTime === 10) this.speak('Ten seconds left', 'en-US');
                    if (currentRoundTime > 0 && currentRoundTime <= 4) this.beep(880, 100);
                    if (!halfTimeAnnouncedInRound && currentRoundTime > 0 && currentRoundTime <= roundDuration / 2) { this.speak('Half time!', 'en-US'); halfTimeAnnouncedInRound = true; }
                    if (currentRoundTime <= 0) { 
                        this.beep(1200, 150); 
                        currentRoundTime = roundDuration; 
                        halfTimeAnnouncedInRound = false; 
                        if(totalDuration >= 0) this.currentEmomRound++;
                    }
                    updateEmomDisplay();
                    if (totalDuration < 0) { 
                        clearInterval(this.countdownInterval); 
                        if (data.temps.during) this.currentEmomRound = (data.temps.during / data.temps.every) + 1;
                        this.decideNextStep(); 
                    }
                }, 1000);
            },
            startSerieMode(data) {
                this.timerClass = 'timer-action'; this.timerDisplay = 'GO!'; this.isSerieMode = true; },
            finishSerieSet() { this.isSerieMode = false; this.decideNextStep(); },
            runPause(duration, onComplete) {
                this.beep(1400, 200);
                if (duration > 0) {
                    this.timerClass = 'timer-pause'; let remaining = duration;
                    let halfTimeAnnounced = false;
                    this.timerDisplay = remaining;
                    this.countdownInterval = setInterval(() => {
                        if (this.isPaused) return;
                        remaining--; this.timerDisplay = remaining;
                        if (remaining === 10) this.speak('Ten seconds left', 'en-US');
                        if (!halfTimeAnnounced && remaining > 0 && remaining <= duration / 2) {
                            this.speak('Half time!', 'en-US');
                            halfTimeAnnounced = true;
                        }
                        if (remaining > 0 && remaining <= 3) this.beep(880, 100);
                        if (remaining <= 0) { clearInterval(this.countdownInterval); onComplete(); }
                    }, 1000);
                } else { onComplete(); }
            },
            finishWorkout() { 
                if (this.totalTimeInterval) clearInterval(this.totalTimeInterval); 
                this.currentExerciseIndex = this.workoutPlan.length; // Mark all as completed
                this.exerciseName = 'SÉANCE TERMINÉE'; 
                this.timerDisplay = '💪'; 
                this.timerClass = 'timer-done'; 
                this.speak('Workout complete!', 'en-US'); 
                this.isPaused = false; 
                this.isSerieMode = false; 
                this.releaseWakeLock(); 
            }
        },
        unmounted() { this.releaseWakeLock(); if (this.totalTimeInterval) clearInterval(this.totalTimeInterval); }
    }).mount('#app');
</script>
</body>
</html>