<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Anneaux !</title>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <style>
        :root {
            --prep-color: #ff9800;
            --action-color: #a855f7; /* Purple from screenshot */
            --pause-color: #17a2b8;
            --done-color: #28a745;
            --track-color: #373737;
            --bg-color: #000;
            --text-color: #fff;
            --text-secondary-color: #aaa;
        }
        html, body { height: 100%; width: 100%; }
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; display: flex; align-items: center; justify-content: center; margin: 0; background-color: var(--bg-color); color: var(--text-color); }
        body.editing { overflow-y: auto; align-items: flex-start; }
        body.workout { overflow: hidden; align-items: flex-start; }
        #app { text-align: center; background: var(--bg-color); padding: 1rem; width: 100%; height: 100vh; display: flex; flex-direction: column; justify-content: center; position: relative; box-sizing: border-box; }
        #app.workout-mode { justify-content: flex-start; padding-top: 80px; }
        select { width: 95%; padding: 0.8rem; margin-bottom: 1.5rem; border-radius: 4px; border: 1px solid #ccc; font-size: 1.2rem; background-color: #333; color: white; -webkit-appearance: none; -moz-appearance: none; appearance: none; background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23fff%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E'); background-repeat: no-repeat; background-position: right .7em top 50%; background-size: .65em auto; }
        button { padding: 1rem 2rem; font-size: 1.2rem; cursor: pointer; border: none; background-color: var(--action-color); color: white; border-radius: 8px; width: 90%; }
        button:disabled { background-color: #a0a0a0; cursor: not-allowed; }
        
        .workout-view { display: flex; flex-direction: column; height: 100%; }
        .main-display { flex-grow: 1; display: flex; flex-direction: column; justify-content: center; align-items: center; }
        #plan-container { flex-shrink: 0; padding: 10px; border-top: 1px solid var(--track-color); max-height: 40%; overflow-y: auto; background-color: #111; }
        .plan-list { list-style: none; padding: 0; margin: 0; text-align: left; font-size: 1.6em}
        .plan-list li { display: flex; flex-direction: column; padding: 8px 5px; border-bottom: 1px solid var(--track-color); font-size: 1rem; }
        .plan-list li .exercise-main { display: flex; align-items: center; }
        .plan-list li.current { color: gray; }

        .sub-tasks { padding-left: 25px; margin-top: 5px; display: flex; align-items: center; flex-wrap: wrap; }
        .sub-tasks label { font-size: 0.8rem; margin-right: 5px; font-style: italic; }

        h1 {
            margin-top: 1rem;
            margin-bottom: 1rem;
            font-size: 1.8rem;
            font-weight: bold;

            white-space: normal;
            overflow-wrap: break-word;
            padding: 0 1rem;
        }
        
        .circle-timer { width: 80vw; max-width: 400px; position: relative; aspect-ratio: 1 / 1; }
        .circle-timer svg { transform: rotate(-90deg); width: 100%; height: 100%; }
        .timer-track, .timer-progress { fill: none; stroke-width: 10; }
        .timer-track { stroke: var(--track-color); stroke-dasharray: 5 5; }
        .timer-progress { stroke: var(--action-color); stroke-linecap: round; transition: stroke-dashoffset 0.3s linear, stroke 0.3s ease; }

        .timer-text-container { position: absolute; top: 0; left: 0; right: 0; bottom: 0; display: flex; flex-direction: column; align-items: center; justify-content: center; }
        .timer-text { font-size: clamp(3.5rem, 18vw, 5.5rem); font-weight: bold; font-family: "Courier New", Courier, monospace; }
        .timer-subtext { font-size: 2.2rem;  margin-top: 10px; }
        .timer-pause-text { font-size: 1.5rem; color: var(--pause-color); margin-top: 5px; }

        .pause-btn { position: absolute; top: 25px; left: 15px; width: 45px; height: 45px; padding: 0; font-size: 1.3rem; border-radius: 50%; z-index: 10; background-color: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); color: #fff; }
        .fullscreen-btn { position: absolute; top: 25px; left: 70px; width: 45px; height: 45px; padding: 0; font-size: 1.3rem; border-radius: 50%; z-index: 10; background-color: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); color: #fff; }
        .skip-btn { position: absolute; top: 25px; left: 125px; width: 45px; height: 45px; padding: 0; font-size: 1.3rem; border-radius: 50%; z-index: 10; background-color: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); color: #fff; }
        .total-time-display { position: absolute; top: 30px; right: 20px; font-size: 1.3rem; color: var(--text-secondary-color); }
        
        .ok-btn {
            width: auto; padding: 10px 20px; font-size: 1rem; margin-top: 0px; color: white; border: none; border-radius: 8px; cursor: pointer; margin-bottom: 10px;
            background-color: var(--done-color);
        }

        /* Styles pour l'éditeur de séance */
        .editor-view { 
            padding: 1rem; 
            width: 100%; 
            max-width: 800px; 
            box-sizing: border-box;
            min-height: 100vh;
            overflow-y: auto;
            text-align: left;
        }
        .editor-header { 
            display: flex; 
            justify-content: space-between; 
            align-items: center; 
            margin-bottom: 1rem; 
            position: sticky;
            top: 0;
            background-color: var(--bg-color);
            padding: 10px 0;
            border-bottom: 1px solid var(--track-color);
            z-index: 10;
        }
        .editor-header h2 { margin: 0; }
        .editor-actions { display: flex; gap: 10px; }
        .editor-actions button { padding: 8px 16px; font-size: 0.9rem; border: none; border-radius: 4px; cursor: pointer; }
        .btn-secondary { background-color: #6c757d; color: white; }
        .btn-primary { background-color: var(--action-color); color: white; }
        
        .exercise-editor { 
            border: 1px solid var(--track-color); 
            border-radius: 8px; 
            margin-bottom: 10px; 
            padding: 15px; 
            background-color: #111; 
            box-sizing: border-box;
            overflow: hidden;
        }
        .exercise-header { 
            display: flex; 
            justify-content: space-between; 
            align-items: flex-start; 
            margin-bottom: 10px; 
            flex-wrap: wrap;
            gap: 10px;
        }
        .exercise-title { 
            font-weight: bold; 
            font-size: 1.1rem; 
            flex-grow: 1; 
            word-wrap: break-word;
            overflow-wrap: break-word;
            min-width: 0;
        }
        .exercise-controls { 
            display: flex; 
            gap: 8px; 
            flex-shrink: 0;
        }
        .exercise-controls button { 
            padding: 4px 8px; 
            font-size: 0.8rem; 
            border: none; 
            border-radius: 4px; 
            cursor: pointer; 
            white-space: nowrap;
        }
        .btn-add { background-color: var(--done-color); color: white; }
        .btn-remove { background-color: #dc3545; color: white; }
        
        .exercise-details { 
            font-size: 0.9rem; 
            color: var(--text-secondary-color); 
            word-wrap: break-word;
            overflow-wrap: break-word;
        }
        .exercise-details div { 
            margin: 5px 0; 
        }
        
        .repetition-controls { display: flex; align-items: center; gap: 10px; margin-top: 10px; }
        .repetition-controls label { font-size: 0.9rem; }
        .repetition-controls input { width: 60px; padding: 4px; border: 1px solid #555; border-radius: 4px; background-color: #333; color: white; text-align: center; }
        .repetition-controls button { padding: 2px 6px; font-size: 0.8rem; }

        /* Styles pour l'édition complète des exercices */
        .exercise-param { 
            display: flex; 
            align-items: center; 
            gap: 10px; 
            margin: 8px 0; 
            flex-wrap: wrap;
        }
        .exercise-param label { 
            min-width: 120px; 
            font-size: 0.9rem; 
            font-weight: bold; 
            word-wrap: break-word;
            overflow-wrap: break-word;
        }
        .exercise-param input, .exercise-param select { 
            padding: 6px; 
            border: 1px solid #555; 
            border-radius: 4px; 
            background-color: #333; 
            color: white; 
            font-size: 0.9rem;
            box-sizing: border-box;
        }
        .exercise-param input[type="number"] { 
            width: 80px; 
            text-align: center; 
            flex-shrink: 0;
        }
        .exercise-param input[type="text"] { 
            flex: 1; 
            max-width: 200px; 
            min-width: 120px;
        }
        .exercise-param input[type="checkbox"] { 
            width: 18px; 
            height: 18px; 
            margin-right: 8px;
            accent-color: var(--action-color);
            flex-shrink: 0;
        }
        .exercise-param select { 
            min-width: 100px; 
            flex-shrink: 0;
        }
        .exercise-param span {
            white-space: nowrap;
            flex-shrink: 0;
        }
        
        .param-section { 
            border-top: 1px solid #444; 
            padding-top: 10px; 
            margin-top: 10px; 
            overflow: hidden;
        }
        .param-section h4 { 
            margin: 0 0 10px 0; 
            color: var(--text-secondary-color); 
            font-size: 0.9rem; 
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        /* Styles pour les boutons de la page principale */
        .main-buttons { display: flex; gap: 10px; justify-content: center; margin-top: 15px; width: 100%; }
        .main-buttons button { 
            flex: 1; 
            padding: 12px 20px; 
            font-size: 1.1rem; 
            border: none; 
            border-radius: 8px; 
            cursor: pointer; 
            font-weight: bold;
            max-width: 200px;
        }
        .btn-edit { background-color: #dc3545; color: white; }
        .btn-start { background-color: var(--done-color); color: white; }
        .btn-edit:disabled, .btn-start:disabled { 
            background-color: #a0a0a0; 
            cursor: not-allowed; 
            opacity: 0.6;
        }

        /* Media queries pour petits écrans */
        @media (max-width: 600px) {
            .exercise-param {
                flex-direction: column;
                align-items: flex-start;
                gap: 5px;
            }
            .exercise-param label {
                min-width: auto;
                width: 100%;
            }
            .exercise-param input[type="text"] {
                max-width: 100%;
                width: 100%;
            }
            .exercise-header {
                flex-direction: column;
                align-items: flex-start;
            }
            .exercise-controls {
                margin-top: 10px;
                width: 100%;
                justify-content: flex-end;
            }
        }
    </style>
</head>
<body>
<div id="app">
    <div v-if="!isWorkoutStarted && !isEditing">
        <h2>Choisissez votre séance</h2>
        <select v-model="selectedWorkoutPlan">
            <option :value="null" disabled>-- Sélectionnez un programme --</option>
            <option v-for="(workout, key) in predefinedWorkouts" :key="key" :value="workout.plan">{{ workout.name }}</option>
        </select>
        <br>
        <div class="main-buttons">
            <button @click="editWorkout" :disabled="!selectedWorkoutPlan" class="btn-edit">Éditer la séance</button>
            <button @click="startWorkout" :disabled="!selectedWorkoutPlan" class="btn-start">Commencer directement</button>
        </div>
    </div>

    <div v-if="isEditing" class="editor-view">
        <div class="editor-header">
            <h2>Éditer la séance</h2>
            <div class="editor-actions">
                <button @click="cancelEdit" class="btn-secondary">Annuler</button>
                <button @click="saveAndStart" class="btn-primary">Sauver et Commencer</button>
            </div>
        </div>

        <button @click="addNewExercise" class="btn-add" style="width: 100%; margin-bottom: 15px; padding: 10px;">+ Ajouter un exercice</button>

        <div v-for="(exercise, index) in editingPlan" :key="index" class="exercise-editor">
            <div class="exercise-header">
                <div class="exercise-title">{{ exercise.nom }}</div>
                <div class="exercise-controls">
                    <button @click="moveExerciseUp(index)" :disabled="index === 0" class="btn-secondary">↑</button>
                    <button @click="moveExerciseDown(index)" :disabled="index === editingPlan.length - 1" class="btn-secondary">↓</button>
                    <button @click="removeExercise(index)" class="btn-remove">Supprimer</button>
                </div>
            </div>
            
            <div class="exercise-details">
                <!-- Paramètres de base -->
                <div class="exercise-param">
                    <label>Nom:</label>
                    <input v-model="exercise.nom" type="text" placeholder="Nom de l'exercice">
                </div>
                
                <div class="exercise-param">
                    <label>Type:</label>
                    <select v-model="exercise.type" @change="onTypeChange(index)">
                        <option value="serie">Série</option>
                        <option value="EMOM">EMOM</option>
                    </select>
                </div>

                <!-- Paramètres spécifiques au type série -->
                <div v-if="exercise.type === 'serie' && exercise.number !== undefined" class="param-section">
                    <h4>Paramètres Série</h4>
                    <div class="exercise-param">
                        <label>Nombre de séries:</label>
                        <input v-model.number="exercise.number" type="number" min="1" max="20">
                    </div>
                    <div class="exercise-param">
                        <label>Repos entre séries:</label>
                        <input v-model.number="exercise.rest" type="number" min="0" max="600">
                        <span>secondes</span>
                    </div>
                </div>

                <!-- Paramètres spécifiques au type EMOM -->
                <div v-if="exercise.type === 'EMOM' && exercise.temps" class="param-section">
                    <h4>Paramètres EMOM</h4>
                    <div class="exercise-param">
                        <label>Intervalle:</label>
                        <input v-model.number="exercise.temps.every" type="number" min="10" max="300">
                        <span>secondes</span>
                    </div>
                    <div class="exercise-param">
                        <label>Durée totale:</label>
                        <input v-model.number="exercise.temps.during" type="number" min="30" max="1800">
                        <span>secondes</span>
                    </div>
                    
                    <div class="exercise-param">
                        <label>Répéter le bloc:</label>
                        <input v-model="exercise.hasRepeat" type="checkbox" @change="onEmomRepeatChange(index)">
                        <span>Oui</span>
                    </div>
                    
                    <div v-if="exercise.hasRepeat && exercise.repeat" class="exercise-param">
                        <label>Nombre de répétitions:</label>
                        <input v-model.number="exercise.repeat.number" type="number" min="1" max="10">
                        <span>fois</span>
                    </div>
                    <div v-if="exercise.hasRepeat && exercise.repeat" class="exercise-param">
                        <label>Pause entre blocs:</label>
                        <input v-model.number="exercise.repeat.pause_between" type="number" min="0" max="300">
                        <span>secondes</span>
                    </div>
                </div>

                <!-- Paramètres de timing -->
                <div class="param-section">
                    <h4>Timing</h4>
                    <div class="exercise-param">
                        <label>Pause après exercice:</label>
                        <input v-model.number="exercise.pause_after" type="number" min="0" max="600">
                        <span>secondes</span>
                    </div>
                    <div class="exercise-param">
                        <label>Préparation avant:</label>
                        <input v-model.number="exercise.countdown_before" type="number" min="0" max="60">
                        <span>secondes</span>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div v-if="isWorkoutStarted" class="workout-view">
        <button @click="togglePause" class="pause-btn">{{ isPaused ? '▶️' : '⏸️' }}</button>
        <button @click="toggleFullscreen" class="fullscreen-btn">⛶</button>
        <button @click="skipToNextExercise" class="skip-btn" v-if="currentExerciseIndex < workoutPlan.length">>></button>
        <div class="total-time-display">{{ formattedTotalTime }}</div>
        
        <div class="main-display">
            <div class="circle-timer">
                <svg viewBox="0 0 100 100">
                    <circle class="timer-track" cx="50" cy="50" r="45"></circle>
                    <circle class="timer-progress" cx="50" cy="50" r="45" :style="progressStyle"></circle>
                </svg>
                <div class="timer-text-container">
                    <div class="timer-text" :style="{ color: phaseColor }">{{ timerDisplay }}</div>
                    <div class="timer-subtext" :style="{ color: phaseColor }">{{ timerSubtext }}</div>
                    <div v-if="isBreakTime" class="timer-pause-text">en pause</div>
                </div>
            </div>
            <h1 :style="{ color: phaseColor }">{{ exerciseName }}</h1>
            <button v-if="isSerieMode && !isPaused" @click="finishSerieSet" class="ok-btn">OK</button>
        </div>

        <div id="plan-container">
            <template v-for="(exercise, index) in workoutPlan" :key="index">
                <li v-if="index >= currentExerciseIndex" :class="{ current: index === currentExerciseIndex }">
                    <div class="exercise-main plan-list">
                        <span>{{ formatExerciseTitle(exercise) }}</span>
                    </div>
                </li>
            </template>
        </div>
    </div>
</div>
<script>
    const { createApp } = Vue;
    createApp({
        data() {
            return {
                predefinedWorkouts: {},
                selectedWorkoutPlan: null,
                workoutPlan: [],
                currentExerciseIndex: -1, currentRepetition: 0, currentEmomRound: 0, isPaused: false, isSerieMode: false, isBreakTime: false,
                totalWorkoutTime: 0, totalTimeInterval: null,
                exerciseName: '', timerDisplay: '', timerSubtext: '',
                countdownInterval: null, isWorkoutStarted: false, wakeLock: null, audioContext: null,
                progressStyle: {}, circleCircumference: 0, phaseColor: 'var(--action-color)',
                // Variables pour l'éditeur
                isEditing: false,
                editingPlan: [],
                originalPlan: null
            };
        },
        async created() {
            const manifestResponse = await fetch('workouts/manifest.json');
            const manifest = await manifestResponse.json();
            const workouts = {};
            for (const fileName of manifest) {
                const workoutName = fileName.replace('.json', '');
                const workoutResponse = await fetch(`workouts/${fileName}`);
                const workoutData = await workoutResponse.json();
                workouts[workoutName] = workoutData;
            }
            this.predefinedWorkouts = workouts;
            this.circleCircumference = 2 * Math.PI * 45; // 45 is the radius 'r' of the circle in SVG
            this.setCircleProgress(0, 'action');

            document.addEventListener('visibilitychange', () => {
                if (document.visibilityState === 'visible' && this.isWorkoutStarted && !this.isPaused) {
                    this.requestWakeLock();
                }
            });
        },
        computed: {
            formattedTotalTime() { if (this.totalWorkoutTime <= 0) return '00:00'; const m = Math.floor(this.totalWorkoutTime / 60); const s = this.totalWorkoutTime % 60; return `${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`; },
        },
        methods: {
            toggleFullscreen() {
                const isInFullScreen = document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement || document.msFullscreenElement;

                if (!isInFullScreen) {
                    const el = document.documentElement;
                    if (el.requestFullscreen) {
                        el.requestFullscreen();
                    } else if (el.mozRequestFullScreen) { /* Firefox */
                        el.mozRequestFullScreen();
                    } else if (el.webkitRequestFullscreen) { /* Chrome, Safari & Opera */
                        el.webkitRequestFullscreen();
                    } else if (el.msRequestFullscreen) { /* IE/Edge */
                        el.msRequestFullscreen();
                    }
                } else {
                    if (document.exitFullscreen) {
                        document.exitFullscreen();
                    } else if (document.mozCancelFullScreen) { /* Firefox */
                        document.mozCancelFullScreen();
                    } else if (document.webkitExitFullscreen) { /* Chrome, Safari & Opera */
                        document.webkitExitFullscreen();
                    } else if (document.msExitFullscreen) { /* IE/Edge */
                        document.msExitFullscreen();
                    }
                }
            },
            // Méthodes pour l'éditeur de séance
            editWorkout() {
                if (!this.selectedWorkoutPlan) return;
                this.originalPlan = JSON.parse(JSON.stringify(this.selectedWorkoutPlan));
                this.editingPlan = JSON.parse(JSON.stringify(this.selectedWorkoutPlan));
                
                // S'assurer que tous les exercices ont les bonnes propriétés
                this.editingPlan = this.editingPlan.map(exercise => {
                    const newExercise = { ...exercise };
                    
                    // Propriétés communes
                    if (newExercise.pause_after === undefined) newExercise.pause_after = 30;
                    if (newExercise.countdown_before === undefined) newExercise.countdown_before = 5;
                    
                    // Propriétés spécifiques par type
                    if (newExercise.type === 'serie') {
                        if (!newExercise.number) newExercise.number = 3;
                        if (newExercise.rest === undefined) newExercise.rest = 60;
                    } else if (newExercise.type === 'EMOM') {
                        if (!newExercise.temps) {
                            newExercise.temps = { every: 60, during: 300 };
                        } else {
                            // S'assurer que temps a toutes les propriétés nécessaires
                            if (!newExercise.temps.every) newExercise.temps.every = 60;
                            if (!newExercise.temps.during) newExercise.temps.during = 300;
                        }
                        // Initialiser hasRepeat basé sur l'existence de repeat
                        newExercise.hasRepeat = !!newExercise.repeat;
                        if (newExercise.hasRepeat && !newExercise.repeat) {
                            newExercise.repeat = { number: 1, pause_between: 30 };
                        }
                    }
                    
                    return newExercise;
                });
                
                this.isEditing = true;
                document.body.classList.add('editing');
                document.body.classList.remove('workout');
            },
            cancelEdit() {
                this.isEditing = false;
                this.editingPlan = [];
                this.originalPlan = null;
                document.body.classList.remove('editing');
                document.getElementById('app').classList.remove('workout-mode');
            },
            saveAndStart() {
                // Nettoyer les propriétés helper avant de sauvegarder
                const cleanedPlan = JSON.parse(JSON.stringify(this.editingPlan));
                cleanedPlan.forEach((exercise, index) => {
                    // Supprimer la propriété helper hasRepeat
                    const originalExercise = this.editingPlan[index];
                    delete exercise.hasRepeat;
                    // Si EMOM sans répétition, s'assurer que repeat n'existe pas
                    if (exercise.type === 'EMOM' && !originalExercise.hasRepeat) {
                        delete exercise.repeat;
                    }
                });
                
                this.selectedWorkoutPlan = cleanedPlan;
                this.isEditing = false;
                document.body.classList.remove('editing');
                this.startWorkout();
            },
            removeExercise(index) {
                if (this.editingPlan.length > 1) {
                    this.editingPlan.splice(index, 1);
                }
            },
            moveExerciseUp(index) {
                if (index > 0) {
                    const exercise = this.editingPlan.splice(index, 1)[0];
                    this.editingPlan.splice(index - 1, 0, exercise);
                }
            },
            moveExerciseDown(index) {
                if (index < this.editingPlan.length - 1) {
                    const exercise = this.editingPlan.splice(index, 1)[0];
                    this.editingPlan.splice(index + 1, 0, exercise);
                }
            },
            increaseReps(index) {
                if (this.editingPlan[index].type === 'serie') {
                    this.editingPlan[index].number++;
                }
            },
            decreaseReps(index) {
                if (this.editingPlan[index].type === 'serie' && this.editingPlan[index].number > 1) {
                    this.editingPlan[index].number--;
                }
            },
            increaseEmomReps(index) {
                if (this.editingPlan[index].type === 'EMOM' && this.editingPlan[index].repeat) {
                    this.editingPlan[index].repeat.number++;
                }
            },
            decreaseEmomReps(index) {
                if (this.editingPlan[index].type === 'EMOM' && this.editingPlan[index].repeat && this.editingPlan[index].repeat.number > 1) {
                    this.editingPlan[index].repeat.number--;
                }
            },
            onTypeChange(index) {
                const exercise = this.editingPlan[index];
                
                // Créer un nouvel objet exercice avec les bonnes propriétés
                const newExercise = {
                    nom: exercise.nom,
                    type: exercise.type,
                    pause_after: exercise.pause_after !== undefined ? exercise.pause_after : 30,
                    countdown_before: exercise.countdown_before !== undefined ? exercise.countdown_before : 5
                };
                
                if (exercise.type === 'serie') {
                    // Propriétés spécifiques aux séries
                    newExercise.number = exercise.number || 3;
                    newExercise.rest = exercise.rest !== undefined ? exercise.rest : 60;
                } else if (exercise.type === 'EMOM') {
                    // Propriétés spécifiques aux EMOM
                    newExercise.temps = {
                        every: (exercise.temps && exercise.temps.every) || 60,
                        during: (exercise.temps && exercise.temps.during) || 300
                    };
                    newExercise.hasRepeat = false;
                    // Ne pas ajouter repeat par défaut
                }
                
                // Remplacer l'exercice entier pour assurer la réactivité
                this.editingPlan.splice(index, 1, newExercise);
            },
            onEmomRepeatChange(index) {
                const exercise = this.editingPlan[index];
                if (exercise.hasRepeat) {
                    // Activer les répétitions
                    if (!exercise.repeat) {
                        exercise.repeat = { number: 1, pause_between: 30 };
                    }
                } else {
                    // Désactiver les répétitions
                    delete exercise.repeat;
                }
                // Déclencher une mise à jour réactive
                this.editingPlan[index] = { ...exercise };
            },
            addNewExercise() {
                const newExercise = {
                    nom: "Nouvel exercice",
                    type: "serie",
                    number: 3,
                    rest: 60,
                    pause_after: 30,
                    countdown_before: 5
                };
                this.editingPlan.push(newExercise);
            },
            setCircleProgress(percent, phase) {
                const offset = this.circleCircumference - (percent / 100) * this.circleCircumference;
                let color = 'var(--action-color)';
                if (phase === 'prep') color = 'var(--prep-color)';
                else if (phase === 'pause') color = 'var(--pause-color)';
                else if (phase === 'done') color = 'var(--done-color)';
                this.progressStyle = {
                    strokeDasharray: `${this.circleCircumference}`,
                    strokeDashoffset: offset,
                    stroke: color
                };
                this.phaseColor = color;
            },
            formatExerciseTitle(exercise) {
                let parts = [exercise.nom.split(' ').map(word => word.toUpperCase()).join(' ')];
                if (exercise.type) { parts.push(exercise.type.toUpperCase()); }
                let repCount = 0;
                if (exercise.type === 'serie' && exercise.number) { repCount = exercise.number; }
                else if (exercise.type === 'EMOM') {
                    if (exercise.repeat && exercise.repeat.number) { repCount = exercise.repeat.number; }
                    else if (exercise.temps && exercise.temps.during && exercise.temps.every) { repCount = Math.floor(exercise.temps.during / exercise.temps.every); }
                }
                if (repCount > 1) { parts.push(repCount); }
                return parts.join(' - ');
            },
            skipToNextExercise() { if (this.countdownInterval) { clearInterval(this.countdownInterval); } this.startNextExercise(); },
            speak(text, lang = 'en-US') { if ('speechSynthesis' in window) { window.speechSynthesis.cancel(); const u = new SpeechSynthesisUtterance(text); u.lang = lang; u.rate = 0.9; window.speechSynthesis.speak(u); } },
            beep(freq = 880, duration = 100) { if (!this.audioContext) return; const o = this.audioContext.createOscillator(); const g = this.audioContext.createGain(); o.connect(g); o.frequency.value = freq; o.type = 'sine'; g.connect(this.audioContext.destination); g.gain.setValueAtTime(1, this.audioContext.currentTime); g.gain.exponentialRampToValueAtTime(0.00001, this.audioContext.currentTime + duration / 1000); o.start(); o.stop(this.audioContext.currentTime + duration / 1000); },
            async requestWakeLock() { if ('wakeLock' in navigator && !this.isPaused) try { this.wakeLock = await navigator.wakeLock.request('screen'); } catch (e) { console.error(e); } },
            async releaseWakeLock() { if (this.wakeLock) { await this.wakeLock.release(); this.wakeLock = null; } },
            togglePause() { this.isPaused = !this.isPaused; if (this.isPaused) { if ('speechSynthesis' in window) window.speechSynthesis.pause(); this.releaseWakeLock(); } else { if ('speechSynthesis' in window) window.speechSynthesis.resume(); this.requestWakeLock(); } },
            startWorkout() {
                if (!this.selectedWorkoutPlan) return;
                if (!this.audioContext) this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                if (this.countdownInterval) clearInterval(this.countdownInterval);
                if (this.totalTimeInterval) clearInterval(this.totalTimeInterval);
                const plan = this.selectedWorkoutPlan;
                this.workoutPlan = plan; this.currentExerciseIndex = -1; this.isWorkoutStarted = true; this.isPaused = false; this.isSerieMode = false;
                this.totalWorkoutTime = 0;
                this.totalTimeInterval = setInterval(() => { if (!this.isPaused) this.totalWorkoutTime++; }, 1000);
                document.body.classList.add('workout');
                document.body.classList.remove('editing');
                document.getElementById('app').classList.add('workout-mode');
                this.requestWakeLock();
                this.startNextExercise();
            },
            decideNextStep() {
                const exercise = this.workoutPlan[this.currentExerciseIndex];
                if (exercise.type === 'serie' && this.currentRepetition < exercise.number) {
                    this.currentRepetition++;
                    this.runPause(exercise.rest || 0, () => this.startSerieMode(exercise), 'pause', `${this.currentRepetition}/${exercise.number}`);
                } else if (exercise.repeat && this.currentRepetition < exercise.repeat.number) {
                    let subtext = null;
                    if (exercise.type === 'EMOM' && exercise.repeat) {
                        subtext = `${this.currentRepetition}/${exercise.repeat.number}`;
                    }
                    this.runPause(exercise.repeat.pause_between || 0, () => {
                        this.currentRepetition++;
                        this.startMainTimer(exercise);
                    }, 'pause', subtext);
                } else {
                    if (exercise.repeat || exercise.type === 'serie') { this.currentRepetition++; }
                    const nextIndex = this.currentExerciseIndex + 1;
                    if (nextIndex < this.workoutPlan.length) {
                        this.exerciseName = this.workoutPlan[nextIndex].nom.toUpperCase();
                    }
                    const pauseDuration = (nextIndex < this.workoutPlan.length) ? (exercise.pause_after || 0) : 0;
                    this.runPause(pauseDuration, () => this.startNextExercise());
                }
            },
            startNextExercise() {
                this.isSerieMode = false;
                this.currentExerciseIndex++;
                if (this.currentExerciseIndex >= this.workoutPlan.length) { this.finishWorkout(); return; }
                this.currentRepetition = 1;
                this.currentEmomRound = 0;
                const exercise = this.workoutPlan[this.currentExerciseIndex];
                this.exerciseName = exercise.nom.toUpperCase();
                this.startPreparation(exercise);
            },
            startPreparation(data) {
                let subtext = null;
                if (data.type === 'EMOM' && data.repeat) {
                    subtext = `${this.currentRepetition}/${data.repeat.number}`;
                }
                this.runPause(data.countdown_before || 0, () => this.startMainTimer(data), 'prep', subtext);
            },
            startMainTimer(data) { this.beep(1200, 150); if (data.type === 'serie') this.startSerieMode(data); else if (data.type === 'EMOM') this.startEmomTimer(data); },
            startEmomTimer(data) {
                this.isBreakTime = false;
                this.currentEmomRound = 1;
                let totalDuration = data.temps.during || 0; const roundDuration = data.temps.every || 60; let currentRoundTime = roundDuration;
                let halfTimeAnnouncedInRound = false;
                const update = () => {
                    this.timerDisplay = `${String(Math.floor(currentRoundTime/60)).padStart(2,'0')}:${String(currentRoundTime%60).padStart(2,'0')}`;
                    const percent = roundDuration > 0 ? ((roundDuration - currentRoundTime) / roundDuration) * 100 : 0;
                    this.setCircleProgress(percent, 'action');
                    if (data.repeat) { this.timerSubtext = `${this.currentRepetition}/${data.repeat.number}`; }
                    else { this.timerSubtext = `${this.currentEmomRound}/${Math.floor(data.temps.during / data.temps.every)}`; }
                };
                update();
                this.countdownInterval = setInterval(() => {
                    if (this.isPaused) return;
                    totalDuration--; currentRoundTime--;
                    if (currentRoundTime === 10 && roundDuration >= 30) this.speak('Ten seconds left', 'en-US');
                    if (currentRoundTime > 0 && currentRoundTime <= 4) this.beep(880, 100);
                    if (!halfTimeAnnouncedInRound && currentRoundTime > 0 && currentRoundTime <= roundDuration / 2) {
                        this.speak('Half time!', 'en-US');
                        halfTimeAnnouncedInRound = true;
                    }
                    if (currentRoundTime <= 0) { 
                        this.beep(1200, 150); currentRoundTime = roundDuration; 
                        halfTimeAnnouncedInRound = false;
                        if(totalDuration >= 0) this.currentEmomRound++;
                    }
                    update();
                    if (totalDuration < 0) { 
                        clearInterval(this.countdownInterval); 
                        if (data.temps.during) this.currentEmomRound = (data.temps.during / data.temps.every) + 1;
                        this.decideNextStep(); 
                    }
                }, 1000);
            },
            startSerieMode(data) { this.isBreakTime = false; this.timerSubtext = `${this.currentRepetition}/${data.number}`; this.timerDisplay = 'GO!'; this.isSerieMode = true; this.setCircleProgress(100, 'action'); },
            finishSerieSet() { this.isSerieMode = false; this.decideNextStep(); },
            runPause(duration, onComplete, phase = 'pause', subtext = null) {
                this.isBreakTime = true;
                this.beep(1400, 200);
                if (duration > 0) {
                    this.timerSubtext = subtext !== null ? subtext : (phase === 'prep') ? 'Préparation' : 'Pause';
                    let remaining = duration;
                    let halfTimeAnnounced = false;
                    const update = () => {
                        this.timerDisplay = remaining;
                        const percent = duration > 0 ? ((duration - remaining) / duration) * 100 : 0;
                        this.setCircleProgress(percent, phase);
                    };
                    const onPauseComplete = () => {
                        this.isBreakTime = false;
                        onComplete();
                    };
                    update();
                    this.countdownInterval = setInterval(() => {
                        if (this.isPaused) return;
                        remaining--;
                        if (remaining === 10 && duration >= 30) this.speak('Ten seconds left', 'en-US');
                        if (!halfTimeAnnounced && remaining > 0 && remaining <= duration / 2) {
                            this.speak('Half time!', 'en-US');
                            halfTimeAnnounced = true;
                        }
                        if (remaining > 0 && remaining <= 3) this.beep(880, 100);
                        update();
                        if (remaining < 0) { clearInterval(this.countdownInterval); onPauseComplete(); }
                    }, 1000);
                } else { this.isBreakTime = false; onComplete(); }
            },
            finishWorkout() { 
                if (this.totalTimeInterval) clearInterval(this.totalTimeInterval); 
                this.currentExerciseIndex = this.workoutPlan.length;
                this.exerciseName = 'SÉANCE TERMINÉE'; 
                this.timerDisplay = '💪';
                this.timerSubtext = 'Bravo !';
                this.setCircleProgress(100, 'done');
                this.speak('Workout complete! Well done', 'en-US');
                this.isPaused = false; 
                this.isSerieMode = false; 
                this.releaseWakeLock();
                // Ajouter possibilité de retour après 5 secondes
                setTimeout(() => {
                    this.isWorkoutStarted = false;
                    document.body.classList.remove('workout');
                    document.getElementById('app').classList.remove('workout-mode');
                }, 5000);
            }
        },
        unmounted() { this.releaseWakeLock(); if (this.totalTimeInterval) clearInterval(this.totalTimeInterval); }
    }).mount('#app');
</script>
</body>
</html>