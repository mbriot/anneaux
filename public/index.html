<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Anneaux !</title>
    <link rel="stylesheet" href="styles.css">
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <!-- Composants Vue -->
    <script src="js/CircleTimer.js"></script>
    <script src="js/ExerciseEditor.js"></script>
    <script src="js/WorkoutSelector.js"></script>
    <script src="js/WorkoutEditor.js"></script>
    <script src="js/WorkoutTimer.js"></script>
</head>
<body>
<div id="app">
    <workout-selector v-if="!isWorkoutStarted && !isEditing"
                     :predefined-workouts="predefinedWorkouts"
                     v-model:selected-workout-plan="selectedWorkoutPlan"
                     @edit-workout="editWorkout"
                     @start-workout="startWorkout"></workout-selector>

    <workout-editor v-if="isEditing"
                   :selected-workout-plan="selectedWorkoutPlan"
                   @cancel-edit="cancelEdit"
                   @save-and-start="saveAndStart"></workout-editor>

    <workout-timer v-if="isWorkoutStarted"
                  :workout-plan="workoutPlan"
                  :current-exercise-index="currentExerciseIndex"
                  :exercise-name="exerciseName"
                  :timer-display="timerDisplay"
                  :timer-subtext="timerSubtext"
                  :progress-style="progressStyle"
                  :phase-color="phaseColor"
                  :is-break-time="isBreakTime"
                  :is-paused="isPaused"
                  :is-serie-mode="isSerieMode"
                  :formatted-total-time="formattedTotalTime"
                  @toggle-pause="togglePause"
                  @toggle-fullscreen="toggleFullscreen"
                  @skip-to-next="skipToNextExercise"
                  @finish-serie-set="finishSerieSet"></workout-timer>
</div>

<script>
    const { createApp } = Vue;
    
    createApp({
        components: {
            WorkoutSelector: window.WorkoutSelector,
            WorkoutEditor: window.WorkoutEditor,
            WorkoutTimer: window.WorkoutTimer
        },
        data() {
            return {
                predefinedWorkouts: {},
                selectedWorkoutPlan: null,
                workoutPlan: [],
                currentExerciseIndex: -1, 
                currentRepetition: 0, 
                currentEmomRound: 0, 
                isPaused: false, 
                isSerieMode: false, 
                isBreakTime: false,
                totalWorkoutTime: 0, 
                totalTimeInterval: null,
                exerciseName: '', 
                timerDisplay: '', 
                timerSubtext: '',
                countdownInterval: null, 
                isWorkoutStarted: false, 
                wakeLock: null, 
                audioContext: null,
                progressStyle: {}, 
                circleCircumference: 0, 
                phaseColor: 'var(--action-color)',
                // Variables pour l'√©diteur
                isEditing: false
            };
        },
        async created() {
            const manifestResponse = await fetch('workouts/manifest.json');
            const manifest = await manifestResponse.json();
            const workouts = {};
            for (const fileName of manifest) {
                const workoutName = fileName.replace('.json', '');
                const workoutResponse = await fetch(`workouts/${fileName}`);
                const workoutData = await workoutResponse.json();
                workouts[workoutName] = workoutData;
            }
            this.predefinedWorkouts = workouts;
            this.circleCircumference = 2 * Math.PI * 45; // 45 is the radius 'r' of the circle in SVG
            this.setCircleProgress(0, 'action');

            document.addEventListener('visibilitychange', () => {
                if (document.visibilityState === 'visible' && this.isWorkoutStarted && !this.isPaused) {
                    this.requestWakeLock();
                }
            });
        },
        computed: {
            formattedTotalTime() { 
                if (this.totalWorkoutTime <= 0) return '00:00'; 
                const m = Math.floor(this.totalWorkoutTime / 60); 
                const s = this.totalWorkoutTime % 60; 
                return `${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`; 
            },
        },
        methods: {
            // M√©thodes pour l'√©diteur de s√©ance
            editWorkout() {
                if (!this.selectedWorkoutPlan) return;
                this.isEditing = true;
                document.body.classList.add('editing');
                document.body.classList.remove('workout');
            },
            cancelEdit() {
                this.isEditing = false;
                document.body.classList.remove('editing');
                document.getElementById('app').classList.remove('workout-mode');
            },
            saveAndStart(cleanedPlan) {
                this.selectedWorkoutPlan = cleanedPlan;
                this.isEditing = false;
                document.body.classList.remove('editing');
                this.startWorkout();
            },
            
            // M√©thodes pour le minuteur circulaire
            setCircleProgress(percent, phase) {
                const offset = this.circleCircumference - (percent / 100) * this.circleCircumference;
                let color = 'var(--action-color)';
                if (phase === 'prep') color = 'var(--prep-color)';
                else if (phase === 'pause') color = 'var(--pause-color)';
                else if (phase === 'done') color = 'var(--done-color)';
                this.progressStyle = {
                    strokeDasharray: `${this.circleCircumference}`,
                    strokeDashoffset: offset,
                    stroke: color
                };
                this.phaseColor = color;
            },
            
            // M√©thodes pour le contr√¥le de l'√©cran
            toggleFullscreen() {
                const isInFullScreen = document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement || document.msFullscreenElement;

                if (!isInFullScreen) {
                    const el = document.documentElement;
                    if (el.requestFullscreen) {
                        el.requestFullscreen();
                    } else if (el.mozRequestFullScreen) { /* Firefox */
                        el.mozRequestFullScreen();
                    } else if (el.webkitRequestFullscreen) { /* Chrome, Safari & Opera */
                        el.webkitRequestFullscreen();
                    } else if (el.msRequestFullscreen) { /* IE/Edge */
                        el.msRequestFullscreen();
                    }
                } else {
                    if (document.exitFullscreen) {
                        document.exitFullscreen();
                    } else if (document.mozCancelFullScreen) { /* Firefox */
                        document.mozCancelFullScreen();
                    } else if (document.webkitExitFullscreen) { /* Chrome, Safari & Opera */
                        document.webkitExitFullscreen();
                    } else if (document.msExitFullscreen) { /* IE/Edge */
                        document.msExitFullscreen();
                    }
                }
            },
            
            // M√©thodes pour les contr√¥les d'entra√Ænement
            skipToNextExercise() { 
                if (this.countdownInterval) { 
                    clearInterval(this.countdownInterval); 
                } 
                this.startNextExercise(); 
            },
            
            // M√©thodes audio
            speak(text, lang = 'en-US') { 
                if ('speechSynthesis' in window) { 
                    window.speechSynthesis.cancel(); 
                    const u = new SpeechSynthesisUtterance(text); 
                    u.lang = lang; 
                    u.rate = 0.9; 
                    window.speechSynthesis.speak(u); 
                } 
            },
            beep(freq = 880, duration = 100) { 
                if (!this.audioContext) return; 
                const o = this.audioContext.createOscillator(); 
                const g = this.audioContext.createGain(); 
                o.connect(g); 
                o.frequency.value = freq; 
                o.type = 'sine'; 
                g.connect(this.audioContext.destination); 
                g.gain.setValueAtTime(1, this.audioContext.currentTime); 
                g.gain.exponentialRampToValueAtTime(0.00001, this.audioContext.currentTime + duration / 1000); 
                o.start(); 
                o.stop(this.audioContext.currentTime + duration / 1000); 
            },
            
            // M√©thodes pour Wake Lock
            async requestWakeLock() { 
                if ('wakeLock' in navigator && !this.isPaused) 
                    try { 
                        this.wakeLock = await navigator.wakeLock.request('screen'); 
                    } catch (e) { 
                        console.error(e); 
                    }
            },
            async releaseWakeLock() { 
                if (this.wakeLock) { 
                    await this.wakeLock.release(); 
                    this.wakeLock = null; 
                } 
            },
            
            // M√©thodes de contr√¥le d'entra√Ænement
            togglePause() { 
                this.isPaused = !this.isPaused; 
                if (this.isPaused) { 
                    if ('speechSynthesis' in window) window.speechSynthesis.pause(); 
                    this.releaseWakeLock(); 
                } else { 
                    if ('speechSynthesis' in window) window.speechSynthesis.resume(); 
                    this.requestWakeLock(); 
                } 
            },
            
            // D√©marrage d'entra√Ænement
            startWorkout() {
                if (!this.selectedWorkoutPlan) return;
                if (!this.audioContext) this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                if (this.countdownInterval) clearInterval(this.countdownInterval);
                if (this.totalTimeInterval) clearInterval(this.totalTimeInterval);
                const plan = this.selectedWorkoutPlan;
                this.workoutPlan = plan; 
                this.currentExerciseIndex = -1; 
                this.isWorkoutStarted = true; 
                this.isPaused = false; 
                this.isSerieMode = false;
                this.totalWorkoutTime = 0;
                this.totalTimeInterval = setInterval(() => { 
                    if (!this.isPaused) this.totalWorkoutTime++; 
                }, 1000);
                document.body.classList.add('workout');
                document.body.classList.remove('editing');
                document.getElementById('app').classList.add('workout-mode');
                this.requestWakeLock();
                this.startNextExercise();
            },
            
            // Logique d'entra√Ænement
            decideNextStep() {
                const exercise = this.workoutPlan[this.currentExerciseIndex];
                if (exercise.type === 'serie' && this.currentRepetition < exercise.number) {
                    this.currentRepetition++;
                    this.runPause(exercise.rest || 0, () => this.startSerieMode(exercise), 'pause', `${this.currentRepetition}/${exercise.number}`);
                } else if (exercise.repeat && this.currentRepetition < exercise.repeat.number) {
                    let subtext = null;
                    if (exercise.type === 'EMOM' && exercise.repeat) {
                        subtext = `${this.currentRepetition}/${exercise.repeat.number}`;
                    }
                    this.runPause(exercise.repeat.pause_between || 0, () => {
                        this.currentRepetition++;
                        this.startMainTimer(exercise);
                    }, 'pause', subtext);
                } else {
                    if (exercise.repeat || exercise.type === 'serie') { 
                        this.currentRepetition++; 
                    }
                    const nextIndex = this.currentExerciseIndex + 1;
                    if (nextIndex < this.workoutPlan.length) {
                        this.exerciseName = this.workoutPlan[nextIndex].nom.toUpperCase();
                    }
                    const pauseDuration = (nextIndex < this.workoutPlan.length) ? (exercise.pause_after || 0) : 0;
                    this.runPause(pauseDuration, () => this.startNextExercise());
                }
            },
            startNextExercise() {
                this.isSerieMode = false;
                this.currentExerciseIndex++;
                if (this.currentExerciseIndex >= this.workoutPlan.length) { 
                    this.finishWorkout(); 
                    return; 
                }
                this.currentRepetition = 1;
                this.currentEmomRound = 0;
                const exercise = this.workoutPlan[this.currentExerciseIndex];
                this.exerciseName = exercise.nom.toUpperCase();
                this.startPreparation(exercise);
            },
            startPreparation(data) {
                let subtext = null;
                if (data.type === 'EMOM' && data.repeat) {
                    subtext = `${this.currentRepetition}/${data.repeat.number}`;
                }
                this.runPause(data.countdown_before || 0, () => this.startMainTimer(data), 'prep', subtext);
            },
            startMainTimer(data) { 
                this.beep(1200, 150); 
                if (data.type === 'serie') this.startSerieMode(data); 
                else if (data.type === 'EMOM') this.startEmomTimer(data); 
            },
            startEmomTimer(data) {
                this.isBreakTime = false;
                this.currentEmomRound = 1;
                let totalDuration = data.temps.during || 0; 
                const roundDuration = data.temps.every || 60; 
                let currentRoundTime = roundDuration;
                let halfTimeAnnouncedInRound = false;
                const update = () => {
                    this.timerDisplay = `${String(Math.floor(currentRoundTime/60)).padStart(2,'0')}:${String(currentRoundTime%60).padStart(2,'0')}`;
                    const percent = roundDuration > 0 ? ((roundDuration - currentRoundTime) / roundDuration) * 100 : 0;
                    this.setCircleProgress(percent, 'action');
                    if (data.repeat) { 
                        this.timerSubtext = `${this.currentRepetition}/${data.repeat.number}`; 
                    } else { 
                        this.timerSubtext = `${this.currentEmomRound}/${Math.floor(data.temps.during / data.temps.every)}`; 
                    }
                };
                update();
                this.countdownInterval = setInterval(() => {
                    if (this.isPaused) return;
                    totalDuration--; 
                    currentRoundTime--;
                    if (currentRoundTime === 10 && roundDuration >= 30) this.speak('Ten seconds left', 'en-US');
                    if (currentRoundTime > 0 && currentRoundTime <= 4) this.beep(880, 100);
                    if (!halfTimeAnnouncedInRound && currentRoundTime > 0 && currentRoundTime <= roundDuration / 2) {
                        this.speak('Half time!', 'en-US');
                        halfTimeAnnouncedInRound = true;
                    }
                    if (currentRoundTime <= 0) { 
                        this.beep(1200, 150); 
                        currentRoundTime = roundDuration; 
                        halfTimeAnnouncedInRound = false;
                        if(totalDuration >= 0) this.currentEmomRound++;
                    }
                    update();
                    if (totalDuration < 0) { 
                        clearInterval(this.countdownInterval); 
                        if (data.temps.during) this.currentEmomRound = (data.temps.during / data.temps.every) + 1;
                        this.decideNextStep(); 
                    }
                }, 1000);
            },
            startSerieMode(data) { 
                this.isBreakTime = false; 
                this.timerSubtext = `${this.currentRepetition}/${data.number}`; 
                this.timerDisplay = 'GO!'; 
                this.isSerieMode = true; 
                this.setCircleProgress(100, 'action'); 
            },
            finishSerieSet() { 
                this.isSerieMode = false; 
                this.decideNextStep(); 
            },
            runPause(duration, onComplete, phase = 'pause', subtext = null) {
                this.isBreakTime = true;
                this.beep(1400, 200);
                if (duration > 0) {
                    this.timerSubtext = subtext !== null ? subtext : (phase === 'prep') ? 'Pr√©paration' : 'Pause';
                    let remaining = duration;
                    let halfTimeAnnounced = false;
                    const update = () => {
                        this.timerDisplay = String(remaining);
                        const percent = duration > 0 ? ((duration - remaining) / duration) * 100 : 0;
                        this.setCircleProgress(percent, phase);
                    };
                    const onPauseComplete = () => {
                        this.isBreakTime = false;
                        onComplete();
                    };
                    update();
                    this.countdownInterval = setInterval(() => {
                        if (this.isPaused) return;
                        remaining--;
                        if (remaining === 10 && duration >= 30) this.speak('Ten seconds left', 'en-US');
                        if (!halfTimeAnnounced && remaining > 0 && remaining <= duration / 2) {
                            this.speak('Half time!', 'en-US');
                            halfTimeAnnounced = true;
                        }
                        if (remaining > 0 && remaining <= 3) this.beep(880, 100);
                        update();
                        if (remaining < 0) { 
                            clearInterval(this.countdownInterval); 
                            onPauseComplete(); 
                        }
                    }, 1000);
                } else { 
                    this.isBreakTime = false; 
                    onComplete(); 
                }
            },
            finishWorkout() { 
                if (this.totalTimeInterval) clearInterval(this.totalTimeInterval); 
                this.currentExerciseIndex = this.workoutPlan.length;
                this.exerciseName = 'S√âANCE TERMIN√âE'; 
                this.timerDisplay = 'üí™';
                this.timerSubtext = 'Bravo !';
                this.setCircleProgress(100, 'done');
                this.speak('Workout complete! Well done', 'en-US');
                this.isPaused = false; 
                this.isSerieMode = false; 
                this.releaseWakeLock();
                // Ajouter possibilit√© de retour apr√®s 5 secondes
                setTimeout(() => {
                    this.isWorkoutStarted = false;
                    document.body.classList.remove('workout');
                    document.getElementById('app').classList.remove('workout-mode');
                }, 5000);
            }
        },
        unmounted() { 
            this.releaseWakeLock(); 
            if (this.totalTimeInterval) clearInterval(this.totalTimeInterval); 
        }
    }).mount('#app');
</script>
</body>
</html>